# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.


import collections

from sys import version_info as _version_info
if _version_info < (3, 6, 0):
    raise RuntimeError("Python 3.6 or later required")


from . import _ITKCommonPython



from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _itkImagePython
else:
    import _itkImagePython

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

_swig_new_instance_method = _itkImagePython.SWIG_PyInstanceMethod_New
_swig_new_static_method = _itkImagePython.SWIG_PyStaticMethod_New

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import collections.abc
import itk.itkOffsetPython
import itk.itkSizePython
import itk.pyBasePython
import itk.itkFixedArrayPython
import itk.itkRGBAPixelPython
import itk.itkRGBPixelPython
import itk.stdcomplexPython
import itk.itkCovariantVectorPython
import itk.vnl_vectorPython
import itk.vnl_matrixPython
import itk.vnl_vector_refPython
import itk.itkVectorPython
import itk.ITKCommonBasePython
import itk.itkPointPython
import itk.itkImageRegionPython
import itk.itkIndexPython
import itk.itkMatrixPython
import itk.vnl_matrix_fixedPython
import itk.itkSymmetricSecondRankTensorPython
class vectoritkImageRGBUC2(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageRGBUC2_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC2_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC2___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC2___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC2___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC2___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC2___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC2___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC2___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC2___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC2___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC2_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC2_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC2_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC2_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC2_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC2_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC2_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC2_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC2_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC2_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC2_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC2_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC2_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageRGBUC2
        __init__(self, other) -> vectoritkImageRGBUC2

        Parameters
        ----------
        other: std::vector< itkImageRGBUC2_Pointer > const &

        __init__(self, size) -> vectoritkImageRGBUC2

        Parameters
        ----------
        size: std::vector< itkImageRGBUC2_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageRGBUC2

        Parameters
        ----------
        size: std::vector< itkImageRGBUC2_Pointer >::size_type
        value: std::vector< itkImageRGBUC2_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageRGBUC2_swiginit(self, _itkImagePython.new_vectoritkImageRGBUC2(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC2_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC2_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC2_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC2_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC2_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC2_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC2_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC2_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageRGBUC2

# Register vectoritkImageRGBUC2 in _itkImagePython:
_itkImagePython.vectoritkImageRGBUC2_swigregister(vectoritkImageRGBUC2)

class vectoritkImageRGBAUC2(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageRGBAUC2_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC2_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC2___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC2___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC2___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC2___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC2___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC2___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC2___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC2___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC2___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC2_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC2_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC2_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC2_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC2_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC2_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC2_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC2_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC2_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC2_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC2_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC2_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC2_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageRGBAUC2
        __init__(self, other) -> vectoritkImageRGBAUC2

        Parameters
        ----------
        other: std::vector< itkImageRGBAUC2_Pointer > const &

        __init__(self, size) -> vectoritkImageRGBAUC2

        Parameters
        ----------
        size: std::vector< itkImageRGBAUC2_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageRGBAUC2

        Parameters
        ----------
        size: std::vector< itkImageRGBAUC2_Pointer >::size_type
        value: std::vector< itkImageRGBAUC2_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageRGBAUC2_swiginit(self, _itkImagePython.new_vectoritkImageRGBAUC2(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC2_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC2_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC2_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC2_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC2_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC2_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC2_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC2_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageRGBAUC2

# Register vectoritkImageRGBAUC2 in _itkImagePython:
_itkImagePython.vectoritkImageRGBAUC2_swigregister(vectoritkImageRGBAUC2)

class vectoritkImageVF22(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageVF22_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageVF22_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF22___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF22___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF22___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF22___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF22___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF22___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF22___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF22___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF22___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageVF22_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageVF22_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageVF22_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageVF22_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageVF22_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageVF22_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageVF22_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageVF22_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageVF22_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageVF22_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageVF22_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageVF22_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageVF22_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageVF22
        __init__(self, other) -> vectoritkImageVF22

        Parameters
        ----------
        other: std::vector< itkImageVF22_Pointer > const &

        __init__(self, size) -> vectoritkImageVF22

        Parameters
        ----------
        size: std::vector< itkImageVF22_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageVF22

        Parameters
        ----------
        size: std::vector< itkImageVF22_Pointer >::size_type
        value: std::vector< itkImageVF22_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageVF22_swiginit(self, _itkImagePython.new_vectoritkImageVF22(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageVF22_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageVF22_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageVF22_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageVF22_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageVF22_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageVF22_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageVF22_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageVF22_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageVF22

# Register vectoritkImageVF22 in _itkImagePython:
_itkImagePython.vectoritkImageVF22_swigregister(vectoritkImageVF22)

class vectoritkImageVF32(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageVF32_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageVF32_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF32___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF32___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF32___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF32___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF32___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF32___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF32___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF32___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF32___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageVF32_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageVF32_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageVF32_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageVF32_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageVF32_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageVF32_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageVF32_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageVF32_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageVF32_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageVF32_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageVF32_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageVF32_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageVF32_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageVF32
        __init__(self, other) -> vectoritkImageVF32

        Parameters
        ----------
        other: std::vector< itkImageVF32_Pointer > const &

        __init__(self, size) -> vectoritkImageVF32

        Parameters
        ----------
        size: std::vector< itkImageVF32_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageVF32

        Parameters
        ----------
        size: std::vector< itkImageVF32_Pointer >::size_type
        value: std::vector< itkImageVF32_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageVF32_swiginit(self, _itkImagePython.new_vectoritkImageVF32(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageVF32_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageVF32_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageVF32_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageVF32_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageVF32_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageVF32_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageVF32_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageVF32_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageVF32

# Register vectoritkImageVF32 in _itkImagePython:
_itkImagePython.vectoritkImageVF32_swigregister(vectoritkImageVF32)

class vectoritkImageVF42(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageVF42_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageVF42_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF42___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF42___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF42___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF42___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF42___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF42___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF42___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF42___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF42___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageVF42_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageVF42_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageVF42_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageVF42_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageVF42_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageVF42_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageVF42_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageVF42_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageVF42_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageVF42_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageVF42_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageVF42_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageVF42_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageVF42
        __init__(self, other) -> vectoritkImageVF42

        Parameters
        ----------
        other: std::vector< itkImageVF42_Pointer > const &

        __init__(self, size) -> vectoritkImageVF42

        Parameters
        ----------
        size: std::vector< itkImageVF42_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageVF42

        Parameters
        ----------
        size: std::vector< itkImageVF42_Pointer >::size_type
        value: std::vector< itkImageVF42_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageVF42_swiginit(self, _itkImagePython.new_vectoritkImageVF42(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageVF42_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageVF42_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageVF42_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageVF42_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageVF42_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageVF42_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageVF42_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageVF42_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageVF42

# Register vectoritkImageVF42 in _itkImagePython:
_itkImagePython.vectoritkImageVF42_swigregister(vectoritkImageVF42)

class vectoritkImageCVF22(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageCVF22_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF22_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF22___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF22___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF22___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF22___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF22___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF22___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF22___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF22___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF22___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF22_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF22_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF22_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF22_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF22_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF22_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF22_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF22_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF22_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF22_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF22_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF22_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF22_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageCVF22
        __init__(self, other) -> vectoritkImageCVF22

        Parameters
        ----------
        other: std::vector< itkImageCVF22_Pointer > const &

        __init__(self, size) -> vectoritkImageCVF22

        Parameters
        ----------
        size: std::vector< itkImageCVF22_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageCVF22

        Parameters
        ----------
        size: std::vector< itkImageCVF22_Pointer >::size_type
        value: std::vector< itkImageCVF22_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageCVF22_swiginit(self, _itkImagePython.new_vectoritkImageCVF22(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF22_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF22_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF22_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF22_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF22_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF22_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF22_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF22_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageCVF22

# Register vectoritkImageCVF22 in _itkImagePython:
_itkImagePython.vectoritkImageCVF22_swigregister(vectoritkImageCVF22)

class vectoritkImageCVF32(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageCVF32_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF32_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF32___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF32___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF32___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF32___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF32___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF32___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF32___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF32___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF32___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF32_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF32_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF32_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF32_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF32_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF32_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF32_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF32_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF32_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF32_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF32_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF32_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF32_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageCVF32
        __init__(self, other) -> vectoritkImageCVF32

        Parameters
        ----------
        other: std::vector< itkImageCVF32_Pointer > const &

        __init__(self, size) -> vectoritkImageCVF32

        Parameters
        ----------
        size: std::vector< itkImageCVF32_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageCVF32

        Parameters
        ----------
        size: std::vector< itkImageCVF32_Pointer >::size_type
        value: std::vector< itkImageCVF32_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageCVF32_swiginit(self, _itkImagePython.new_vectoritkImageCVF32(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF32_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF32_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF32_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF32_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF32_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF32_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF32_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF32_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageCVF32

# Register vectoritkImageCVF32 in _itkImagePython:
_itkImagePython.vectoritkImageCVF32_swigregister(vectoritkImageCVF32)

class vectoritkImageCVF42(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageCVF42_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF42_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF42___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF42___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF42___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF42___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF42___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF42___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF42___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF42___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF42___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF42_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF42_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF42_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF42_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF42_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF42_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF42_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF42_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF42_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF42_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF42_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF42_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF42_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageCVF42
        __init__(self, other) -> vectoritkImageCVF42

        Parameters
        ----------
        other: std::vector< itkImageCVF42_Pointer > const &

        __init__(self, size) -> vectoritkImageCVF42

        Parameters
        ----------
        size: std::vector< itkImageCVF42_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageCVF42

        Parameters
        ----------
        size: std::vector< itkImageCVF42_Pointer >::size_type
        value: std::vector< itkImageCVF42_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageCVF42_swiginit(self, _itkImagePython.new_vectoritkImageCVF42(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF42_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF42_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF42_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF42_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF42_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF42_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF42_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF42_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageCVF42

# Register vectoritkImageCVF42 in _itkImagePython:
_itkImagePython.vectoritkImageCVF42_swigregister(vectoritkImageCVF42)

class vectoritkImageSS2(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageSS2_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageSS2_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSS2___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSS2___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSS2___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSS2___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSS2___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSS2___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSS2___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSS2___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSS2___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageSS2_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageSS2_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageSS2_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageSS2_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageSS2_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageSS2_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageSS2_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageSS2_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageSS2_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageSS2_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageSS2_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageSS2_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageSS2_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageSS2
        __init__(self, other) -> vectoritkImageSS2

        Parameters
        ----------
        other: std::vector< itkImageSS2_Pointer > const &

        __init__(self, size) -> vectoritkImageSS2

        Parameters
        ----------
        size: std::vector< itkImageSS2_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageSS2

        Parameters
        ----------
        size: std::vector< itkImageSS2_Pointer >::size_type
        value: std::vector< itkImageSS2_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageSS2_swiginit(self, _itkImagePython.new_vectoritkImageSS2(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageSS2_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageSS2_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageSS2_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageSS2_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageSS2_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageSS2_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageSS2_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageSS2_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageSS2

# Register vectoritkImageSS2 in _itkImagePython:
_itkImagePython.vectoritkImageSS2_swigregister(vectoritkImageSS2)

class vectoritkImageUC2(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageUC2_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageUC2_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUC2___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUC2___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUC2___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUC2___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUC2___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUC2___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUC2___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUC2___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUC2___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageUC2_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageUC2_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageUC2_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageUC2_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageUC2_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageUC2_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageUC2_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageUC2_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageUC2_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageUC2_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageUC2_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageUC2_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageUC2_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageUC2
        __init__(self, other) -> vectoritkImageUC2

        Parameters
        ----------
        other: std::vector< itkImageUC2_Pointer > const &

        __init__(self, size) -> vectoritkImageUC2

        Parameters
        ----------
        size: std::vector< itkImageUC2_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageUC2

        Parameters
        ----------
        size: std::vector< itkImageUC2_Pointer >::size_type
        value: std::vector< itkImageUC2_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageUC2_swiginit(self, _itkImagePython.new_vectoritkImageUC2(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageUC2_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageUC2_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageUC2_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageUC2_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageUC2_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageUC2_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageUC2_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageUC2_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageUC2

# Register vectoritkImageUC2 in _itkImagePython:
_itkImagePython.vectoritkImageUC2_swigregister(vectoritkImageUC2)

class vectoritkImageUS2(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageUS2_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageUS2_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUS2___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUS2___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUS2___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUS2___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUS2___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUS2___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUS2___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUS2___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUS2___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageUS2_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageUS2_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageUS2_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageUS2_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageUS2_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageUS2_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageUS2_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageUS2_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageUS2_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageUS2_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageUS2_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageUS2_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageUS2_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageUS2
        __init__(self, other) -> vectoritkImageUS2

        Parameters
        ----------
        other: std::vector< itkImageUS2_Pointer > const &

        __init__(self, size) -> vectoritkImageUS2

        Parameters
        ----------
        size: std::vector< itkImageUS2_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageUS2

        Parameters
        ----------
        size: std::vector< itkImageUS2_Pointer >::size_type
        value: std::vector< itkImageUS2_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageUS2_swiginit(self, _itkImagePython.new_vectoritkImageUS2(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageUS2_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageUS2_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageUS2_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageUS2_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageUS2_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageUS2_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageUS2_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageUS2_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageUS2

# Register vectoritkImageUS2 in _itkImagePython:
_itkImagePython.vectoritkImageUS2_swigregister(vectoritkImageUS2)

class vectoritkImageF2(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageF2_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageF2_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageF2___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageF2___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageF2___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageF2___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageF2___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageF2___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageF2___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageF2___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageF2___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageF2_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageF2_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageF2_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageF2_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageF2_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageF2_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageF2_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageF2_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageF2_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageF2_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageF2_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageF2_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageF2_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageF2
        __init__(self, other) -> vectoritkImageF2

        Parameters
        ----------
        other: std::vector< itkImageF2_Pointer > const &

        __init__(self, size) -> vectoritkImageF2

        Parameters
        ----------
        size: std::vector< itkImageF2_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageF2

        Parameters
        ----------
        size: std::vector< itkImageF2_Pointer >::size_type
        value: std::vector< itkImageF2_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageF2_swiginit(self, _itkImagePython.new_vectoritkImageF2(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageF2_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageF2_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageF2_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageF2_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageF2_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageF2_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageF2_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageF2_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageF2

# Register vectoritkImageF2 in _itkImagePython:
_itkImagePython.vectoritkImageF2_swigregister(vectoritkImageF2)

class vectoritkImageD2(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageD2_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageD2_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageD2___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageD2___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageD2___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageD2___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageD2___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageD2___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageD2___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageD2___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageD2___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageD2_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageD2_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageD2_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageD2_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageD2_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageD2_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageD2_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageD2_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageD2_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageD2_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageD2_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageD2_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageD2_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageD2
        __init__(self, other) -> vectoritkImageD2

        Parameters
        ----------
        other: std::vector< itkImageD2_Pointer > const &

        __init__(self, size) -> vectoritkImageD2

        Parameters
        ----------
        size: std::vector< itkImageD2_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageD2

        Parameters
        ----------
        size: std::vector< itkImageD2_Pointer >::size_type
        value: std::vector< itkImageD2_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageD2_swiginit(self, _itkImagePython.new_vectoritkImageD2(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageD2_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageD2_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageD2_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageD2_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageD2_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageD2_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageD2_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageD2_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageD2

# Register vectoritkImageD2 in _itkImagePython:
_itkImagePython.vectoritkImageD2_swigregister(vectoritkImageD2)

class vectoritkImageCD2(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageCD2_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageCD2_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCD2___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCD2___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCD2___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCD2___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCD2___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCD2___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCD2___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCD2___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCD2___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageCD2_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageCD2_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageCD2_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageCD2_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageCD2_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageCD2_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageCD2_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageCD2_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageCD2_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageCD2_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageCD2_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageCD2_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageCD2_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageCD2
        __init__(self, other) -> vectoritkImageCD2

        Parameters
        ----------
        other: std::vector< itkImageCD2_Pointer > const &

        __init__(self, size) -> vectoritkImageCD2

        Parameters
        ----------
        size: std::vector< itkImageCD2_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageCD2

        Parameters
        ----------
        size: std::vector< itkImageCD2_Pointer >::size_type
        value: std::vector< itkImageCD2_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageCD2_swiginit(self, _itkImagePython.new_vectoritkImageCD2(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageCD2_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageCD2_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageCD2_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageCD2_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageCD2_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageCD2_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageCD2_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageCD2_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageCD2

# Register vectoritkImageCD2 in _itkImagePython:
_itkImagePython.vectoritkImageCD2_swigregister(vectoritkImageCD2)

class vectoritkImageCF2(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageCF2_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageCF2_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCF2___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCF2___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCF2___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCF2___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCF2___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCF2___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCF2___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCF2___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCF2___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageCF2_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageCF2_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageCF2_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageCF2_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageCF2_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageCF2_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageCF2_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageCF2_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageCF2_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageCF2_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageCF2_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageCF2_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageCF2_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageCF2
        __init__(self, other) -> vectoritkImageCF2

        Parameters
        ----------
        other: std::vector< itkImageCF2_Pointer > const &

        __init__(self, size) -> vectoritkImageCF2

        Parameters
        ----------
        size: std::vector< itkImageCF2_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageCF2

        Parameters
        ----------
        size: std::vector< itkImageCF2_Pointer >::size_type
        value: std::vector< itkImageCF2_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageCF2_swiginit(self, _itkImagePython.new_vectoritkImageCF2(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageCF2_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageCF2_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageCF2_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageCF2_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageCF2_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageCF2_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageCF2_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageCF2_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageCF2

# Register vectoritkImageCF2 in _itkImagePython:
_itkImagePython.vectoritkImageCF2_swigregister(vectoritkImageCF2)

class vectoritkImageVD22(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageVD22_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageVD22_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD22___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD22___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD22___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD22___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD22___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD22___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD22___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD22___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD22___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageVD22_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageVD22_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageVD22_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageVD22_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageVD22_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageVD22_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageVD22_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageVD22_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageVD22_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageVD22_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageVD22_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageVD22_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageVD22_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageVD22
        __init__(self, other) -> vectoritkImageVD22

        Parameters
        ----------
        other: std::vector< itkImageVD22_Pointer > const &

        __init__(self, size) -> vectoritkImageVD22

        Parameters
        ----------
        size: std::vector< itkImageVD22_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageVD22

        Parameters
        ----------
        size: std::vector< itkImageVD22_Pointer >::size_type
        value: std::vector< itkImageVD22_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageVD22_swiginit(self, _itkImagePython.new_vectoritkImageVD22(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageVD22_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageVD22_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageVD22_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageVD22_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageVD22_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageVD22_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageVD22_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageVD22_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageVD22

# Register vectoritkImageVD22 in _itkImagePython:
_itkImagePython.vectoritkImageVD22_swigregister(vectoritkImageVD22)

class vectoritkImageVD32(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageVD32_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageVD32_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD32___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD32___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD32___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD32___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD32___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD32___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD32___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD32___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD32___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageVD32_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageVD32_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageVD32_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageVD32_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageVD32_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageVD32_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageVD32_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageVD32_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageVD32_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageVD32_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageVD32_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageVD32_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageVD32_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageVD32
        __init__(self, other) -> vectoritkImageVD32

        Parameters
        ----------
        other: std::vector< itkImageVD32_Pointer > const &

        __init__(self, size) -> vectoritkImageVD32

        Parameters
        ----------
        size: std::vector< itkImageVD32_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageVD32

        Parameters
        ----------
        size: std::vector< itkImageVD32_Pointer >::size_type
        value: std::vector< itkImageVD32_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageVD32_swiginit(self, _itkImagePython.new_vectoritkImageVD32(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageVD32_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageVD32_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageVD32_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageVD32_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageVD32_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageVD32_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageVD32_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageVD32_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageVD32

# Register vectoritkImageVD32 in _itkImagePython:
_itkImagePython.vectoritkImageVD32_swigregister(vectoritkImageVD32)

class vectoritkImageVD42(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageVD42_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageVD42_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD42___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD42___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD42___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD42___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD42___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD42___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD42___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD42___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD42___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageVD42_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageVD42_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageVD42_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageVD42_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageVD42_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageVD42_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageVD42_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageVD42_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageVD42_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageVD42_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageVD42_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageVD42_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageVD42_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageVD42
        __init__(self, other) -> vectoritkImageVD42

        Parameters
        ----------
        other: std::vector< itkImageVD42_Pointer > const &

        __init__(self, size) -> vectoritkImageVD42

        Parameters
        ----------
        size: std::vector< itkImageVD42_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageVD42

        Parameters
        ----------
        size: std::vector< itkImageVD42_Pointer >::size_type
        value: std::vector< itkImageVD42_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageVD42_swiginit(self, _itkImagePython.new_vectoritkImageVD42(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageVD42_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageVD42_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageVD42_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageVD42_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageVD42_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageVD42_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageVD42_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageVD42_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageVD42

# Register vectoritkImageVD42 in _itkImagePython:
_itkImagePython.vectoritkImageVD42_swigregister(vectoritkImageVD42)

class vectoritkImageSI2(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageSI2_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageSI2_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSI2___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSI2___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSI2___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSI2___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSI2___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSI2___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSI2___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSI2___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSI2___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageSI2_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageSI2_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageSI2_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageSI2_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageSI2_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageSI2_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageSI2_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageSI2_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageSI2_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageSI2_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageSI2_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageSI2_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageSI2_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageSI2
        __init__(self, other) -> vectoritkImageSI2

        Parameters
        ----------
        other: std::vector< itkImageSI2_Pointer > const &

        __init__(self, size) -> vectoritkImageSI2

        Parameters
        ----------
        size: std::vector< itkImageSI2_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageSI2

        Parameters
        ----------
        size: std::vector< itkImageSI2_Pointer >::size_type
        value: std::vector< itkImageSI2_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageSI2_swiginit(self, _itkImagePython.new_vectoritkImageSI2(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageSI2_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageSI2_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageSI2_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageSI2_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageSI2_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageSI2_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageSI2_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageSI2_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageSI2

# Register vectoritkImageSI2 in _itkImagePython:
_itkImagePython.vectoritkImageSI2_swigregister(vectoritkImageSI2)

class vectoritkImageUI2(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageUI2_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageUI2_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUI2___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUI2___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUI2___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUI2___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUI2___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUI2___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUI2___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUI2___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUI2___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageUI2_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageUI2_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageUI2_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageUI2_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageUI2_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageUI2_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageUI2_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageUI2_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageUI2_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageUI2_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageUI2_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageUI2_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageUI2_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageUI2
        __init__(self, other) -> vectoritkImageUI2

        Parameters
        ----------
        other: std::vector< itkImageUI2_Pointer > const &

        __init__(self, size) -> vectoritkImageUI2

        Parameters
        ----------
        size: std::vector< itkImageUI2_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageUI2

        Parameters
        ----------
        size: std::vector< itkImageUI2_Pointer >::size_type
        value: std::vector< itkImageUI2_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageUI2_swiginit(self, _itkImagePython.new_vectoritkImageUI2(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageUI2_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageUI2_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageUI2_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageUI2_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageUI2_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageUI2_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageUI2_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageUI2_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageUI2

# Register vectoritkImageUI2 in _itkImagePython:
_itkImagePython.vectoritkImageUI2_swigregister(vectoritkImageUI2)

class vectoritkImageUL2(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageUL2_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageUL2_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUL2___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUL2___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUL2___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUL2___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUL2___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUL2___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUL2___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUL2___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUL2___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageUL2_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageUL2_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageUL2_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageUL2_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageUL2_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageUL2_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageUL2_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageUL2_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageUL2_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageUL2_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageUL2_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageUL2_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageUL2_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageUL2
        __init__(self, other) -> vectoritkImageUL2

        Parameters
        ----------
        other: std::vector< itkImageUL2_Pointer > const &

        __init__(self, size) -> vectoritkImageUL2

        Parameters
        ----------
        size: std::vector< itkImageUL2_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageUL2

        Parameters
        ----------
        size: std::vector< itkImageUL2_Pointer >::size_type
        value: std::vector< itkImageUL2_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageUL2_swiginit(self, _itkImagePython.new_vectoritkImageUL2(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageUL2_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageUL2_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageUL2_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageUL2_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageUL2_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageUL2_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageUL2_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageUL2_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageUL2

# Register vectoritkImageUL2 in _itkImagePython:
_itkImagePython.vectoritkImageUL2_swigregister(vectoritkImageUL2)

class vectoritkImageULL2(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageULL2_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageULL2_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageULL2___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageULL2___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageULL2___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageULL2___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageULL2___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageULL2___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageULL2___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageULL2___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageULL2___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageULL2_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageULL2_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageULL2_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageULL2_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageULL2_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageULL2_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageULL2_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageULL2_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageULL2_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageULL2_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageULL2_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageULL2_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageULL2_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageULL2
        __init__(self, other) -> vectoritkImageULL2

        Parameters
        ----------
        other: std::vector< itkImageULL2_Pointer > const &

        __init__(self, size) -> vectoritkImageULL2

        Parameters
        ----------
        size: std::vector< itkImageULL2_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageULL2

        Parameters
        ----------
        size: std::vector< itkImageULL2_Pointer >::size_type
        value: std::vector< itkImageULL2_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageULL2_swiginit(self, _itkImagePython.new_vectoritkImageULL2(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageULL2_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageULL2_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageULL2_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageULL2_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageULL2_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageULL2_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageULL2_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageULL2_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageULL2

# Register vectoritkImageULL2 in _itkImagePython:
_itkImagePython.vectoritkImageULL2_swigregister(vectoritkImageULL2)

class vectoritkImageB2(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageB2_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageB2_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageB2___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageB2___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageB2___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageB2___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageB2___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageB2___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageB2___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageB2___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageB2___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageB2_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageB2_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageB2_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageB2_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageB2_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageB2_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageB2_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageB2_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageB2_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageB2_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageB2_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageB2_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageB2_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageB2
        __init__(self, other) -> vectoritkImageB2

        Parameters
        ----------
        other: std::vector< itkImageB2_Pointer > const &

        __init__(self, size) -> vectoritkImageB2

        Parameters
        ----------
        size: std::vector< itkImageB2_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageB2

        Parameters
        ----------
        size: std::vector< itkImageB2_Pointer >::size_type
        value: std::vector< itkImageB2_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageB2_swiginit(self, _itkImagePython.new_vectoritkImageB2(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageB2_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageB2_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageB2_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageB2_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageB2_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageB2_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageB2_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageB2_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageB2

# Register vectoritkImageB2 in _itkImagePython:
_itkImagePython.vectoritkImageB2_swigregister(vectoritkImageB2)

class vectoritkImageFAF22(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageFAF22_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF22_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF22___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF22___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF22___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF22___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF22___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF22___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF22___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF22___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF22___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF22_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF22_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF22_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF22_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF22_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF22_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF22_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF22_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF22_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF22_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF22_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF22_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF22_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageFAF22
        __init__(self, other) -> vectoritkImageFAF22

        Parameters
        ----------
        other: std::vector< itkImageFAF22_Pointer > const &

        __init__(self, size) -> vectoritkImageFAF22

        Parameters
        ----------
        size: std::vector< itkImageFAF22_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageFAF22

        Parameters
        ----------
        size: std::vector< itkImageFAF22_Pointer >::size_type
        value: std::vector< itkImageFAF22_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageFAF22_swiginit(self, _itkImagePython.new_vectoritkImageFAF22(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF22_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF22_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF22_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF22_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF22_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF22_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF22_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF22_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageFAF22

# Register vectoritkImageFAF22 in _itkImagePython:
_itkImagePython.vectoritkImageFAF22_swigregister(vectoritkImageFAF22)

class vectoritkImageFAD22(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageFAD22_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD22_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD22___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD22___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD22___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD22___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD22___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD22___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD22___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD22___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD22___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD22_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD22_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD22_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD22_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD22_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD22_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD22_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD22_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD22_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD22_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD22_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD22_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD22_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageFAD22
        __init__(self, other) -> vectoritkImageFAD22

        Parameters
        ----------
        other: std::vector< itkImageFAD22_Pointer > const &

        __init__(self, size) -> vectoritkImageFAD22

        Parameters
        ----------
        size: std::vector< itkImageFAD22_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageFAD22

        Parameters
        ----------
        size: std::vector< itkImageFAD22_Pointer >::size_type
        value: std::vector< itkImageFAD22_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageFAD22_swiginit(self, _itkImagePython.new_vectoritkImageFAD22(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD22_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD22_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD22_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD22_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD22_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD22_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD22_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD22_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageFAD22

# Register vectoritkImageFAD22 in _itkImagePython:
_itkImagePython.vectoritkImageFAD22_swigregister(vectoritkImageFAD22)

class vectoritkImageO22(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageO22_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageO22_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageO22___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageO22___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageO22___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageO22___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageO22___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageO22___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageO22___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageO22___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageO22___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageO22_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageO22_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageO22_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageO22_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageO22_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageO22_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageO22_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageO22_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageO22_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageO22_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageO22_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageO22_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageO22_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageO22
        __init__(self, other) -> vectoritkImageO22

        Parameters
        ----------
        other: std::vector< itkImageO22_Pointer > const &

        __init__(self, size) -> vectoritkImageO22

        Parameters
        ----------
        size: std::vector< itkImageO22_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageO22

        Parameters
        ----------
        size: std::vector< itkImageO22_Pointer >::size_type
        value: std::vector< itkImageO22_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageO22_swiginit(self, _itkImagePython.new_vectoritkImageO22(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageO22_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageO22_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageO22_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageO22_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageO22_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageO22_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageO22_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageO22_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageO22

# Register vectoritkImageO22 in _itkImagePython:
_itkImagePython.vectoritkImageO22_swigregister(vectoritkImageO22)

class vectoritkImageSSRTD22(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageSSRTD22_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD22_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD22___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD22___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD22___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD22___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD22___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD22___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD22___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD22___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD22___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD22_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD22_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD22_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD22_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD22_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD22_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD22_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD22_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD22_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD22_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD22_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD22_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD22_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageSSRTD22
        __init__(self, other) -> vectoritkImageSSRTD22

        Parameters
        ----------
        other: std::vector< itkImageSSRTD22_Pointer > const &

        __init__(self, size) -> vectoritkImageSSRTD22

        Parameters
        ----------
        size: std::vector< itkImageSSRTD22_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageSSRTD22

        Parameters
        ----------
        size: std::vector< itkImageSSRTD22_Pointer >::size_type
        value: std::vector< itkImageSSRTD22_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageSSRTD22_swiginit(self, _itkImagePython.new_vectoritkImageSSRTD22(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD22_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD22_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD22_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD22_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD22_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD22_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD22_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD22_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageSSRTD22

# Register vectoritkImageSSRTD22 in _itkImagePython:
_itkImagePython.vectoritkImageSSRTD22_swigregister(vectoritkImageSSRTD22)

class vectoritkImageRGBUC3(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageRGBUC3_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC3_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC3___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC3___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC3___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC3___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC3___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC3___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC3___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC3___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC3___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC3_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC3_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC3_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC3_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC3_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC3_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC3_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC3_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC3_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC3_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC3_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC3_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC3_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageRGBUC3
        __init__(self, other) -> vectoritkImageRGBUC3

        Parameters
        ----------
        other: std::vector< itkImageRGBUC3_Pointer > const &

        __init__(self, size) -> vectoritkImageRGBUC3

        Parameters
        ----------
        size: std::vector< itkImageRGBUC3_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageRGBUC3

        Parameters
        ----------
        size: std::vector< itkImageRGBUC3_Pointer >::size_type
        value: std::vector< itkImageRGBUC3_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageRGBUC3_swiginit(self, _itkImagePython.new_vectoritkImageRGBUC3(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC3_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC3_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC3_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC3_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC3_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC3_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC3_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC3_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageRGBUC3

# Register vectoritkImageRGBUC3 in _itkImagePython:
_itkImagePython.vectoritkImageRGBUC3_swigregister(vectoritkImageRGBUC3)

class vectoritkImageRGBAUC3(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageRGBAUC3_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC3_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC3___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC3___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC3___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC3___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC3___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC3___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC3___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC3___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC3___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC3_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC3_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC3_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC3_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC3_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC3_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC3_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC3_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC3_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC3_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC3_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC3_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC3_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageRGBAUC3
        __init__(self, other) -> vectoritkImageRGBAUC3

        Parameters
        ----------
        other: std::vector< itkImageRGBAUC3_Pointer > const &

        __init__(self, size) -> vectoritkImageRGBAUC3

        Parameters
        ----------
        size: std::vector< itkImageRGBAUC3_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageRGBAUC3

        Parameters
        ----------
        size: std::vector< itkImageRGBAUC3_Pointer >::size_type
        value: std::vector< itkImageRGBAUC3_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageRGBAUC3_swiginit(self, _itkImagePython.new_vectoritkImageRGBAUC3(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC3_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC3_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC3_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC3_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC3_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC3_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC3_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC3_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageRGBAUC3

# Register vectoritkImageRGBAUC3 in _itkImagePython:
_itkImagePython.vectoritkImageRGBAUC3_swigregister(vectoritkImageRGBAUC3)

class vectoritkImageVF23(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageVF23_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageVF23_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF23___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF23___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF23___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF23___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF23___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF23___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF23___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF23___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF23___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageVF23_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageVF23_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageVF23_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageVF23_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageVF23_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageVF23_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageVF23_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageVF23_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageVF23_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageVF23_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageVF23_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageVF23_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageVF23_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageVF23
        __init__(self, other) -> vectoritkImageVF23

        Parameters
        ----------
        other: std::vector< itkImageVF23_Pointer > const &

        __init__(self, size) -> vectoritkImageVF23

        Parameters
        ----------
        size: std::vector< itkImageVF23_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageVF23

        Parameters
        ----------
        size: std::vector< itkImageVF23_Pointer >::size_type
        value: std::vector< itkImageVF23_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageVF23_swiginit(self, _itkImagePython.new_vectoritkImageVF23(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageVF23_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageVF23_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageVF23_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageVF23_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageVF23_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageVF23_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageVF23_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageVF23_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageVF23

# Register vectoritkImageVF23 in _itkImagePython:
_itkImagePython.vectoritkImageVF23_swigregister(vectoritkImageVF23)

class vectoritkImageVF33(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageVF33_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageVF33_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF33___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF33___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF33___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF33___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF33___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF33___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF33___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF33___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF33___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageVF33_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageVF33_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageVF33_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageVF33_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageVF33_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageVF33_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageVF33_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageVF33_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageVF33_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageVF33_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageVF33_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageVF33_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageVF33_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageVF33
        __init__(self, other) -> vectoritkImageVF33

        Parameters
        ----------
        other: std::vector< itkImageVF33_Pointer > const &

        __init__(self, size) -> vectoritkImageVF33

        Parameters
        ----------
        size: std::vector< itkImageVF33_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageVF33

        Parameters
        ----------
        size: std::vector< itkImageVF33_Pointer >::size_type
        value: std::vector< itkImageVF33_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageVF33_swiginit(self, _itkImagePython.new_vectoritkImageVF33(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageVF33_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageVF33_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageVF33_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageVF33_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageVF33_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageVF33_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageVF33_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageVF33_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageVF33

# Register vectoritkImageVF33 in _itkImagePython:
_itkImagePython.vectoritkImageVF33_swigregister(vectoritkImageVF33)

class vectoritkImageVF43(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageVF43_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageVF43_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF43___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF43___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF43___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF43___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF43___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF43___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF43___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF43___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF43___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageVF43_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageVF43_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageVF43_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageVF43_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageVF43_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageVF43_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageVF43_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageVF43_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageVF43_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageVF43_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageVF43_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageVF43_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageVF43_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageVF43
        __init__(self, other) -> vectoritkImageVF43

        Parameters
        ----------
        other: std::vector< itkImageVF43_Pointer > const &

        __init__(self, size) -> vectoritkImageVF43

        Parameters
        ----------
        size: std::vector< itkImageVF43_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageVF43

        Parameters
        ----------
        size: std::vector< itkImageVF43_Pointer >::size_type
        value: std::vector< itkImageVF43_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageVF43_swiginit(self, _itkImagePython.new_vectoritkImageVF43(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageVF43_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageVF43_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageVF43_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageVF43_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageVF43_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageVF43_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageVF43_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageVF43_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageVF43

# Register vectoritkImageVF43 in _itkImagePython:
_itkImagePython.vectoritkImageVF43_swigregister(vectoritkImageVF43)

class vectoritkImageCVF23(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageCVF23_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF23_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF23___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF23___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF23___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF23___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF23___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF23___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF23___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF23___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF23___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF23_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF23_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF23_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF23_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF23_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF23_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF23_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF23_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF23_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF23_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF23_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF23_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF23_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageCVF23
        __init__(self, other) -> vectoritkImageCVF23

        Parameters
        ----------
        other: std::vector< itkImageCVF23_Pointer > const &

        __init__(self, size) -> vectoritkImageCVF23

        Parameters
        ----------
        size: std::vector< itkImageCVF23_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageCVF23

        Parameters
        ----------
        size: std::vector< itkImageCVF23_Pointer >::size_type
        value: std::vector< itkImageCVF23_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageCVF23_swiginit(self, _itkImagePython.new_vectoritkImageCVF23(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF23_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF23_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF23_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF23_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF23_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF23_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF23_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF23_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageCVF23

# Register vectoritkImageCVF23 in _itkImagePython:
_itkImagePython.vectoritkImageCVF23_swigregister(vectoritkImageCVF23)

class vectoritkImageCVF33(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageCVF33_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF33_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF33___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF33___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF33___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF33___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF33___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF33___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF33___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF33___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF33___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF33_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF33_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF33_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF33_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF33_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF33_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF33_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF33_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF33_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF33_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF33_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF33_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF33_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageCVF33
        __init__(self, other) -> vectoritkImageCVF33

        Parameters
        ----------
        other: std::vector< itkImageCVF33_Pointer > const &

        __init__(self, size) -> vectoritkImageCVF33

        Parameters
        ----------
        size: std::vector< itkImageCVF33_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageCVF33

        Parameters
        ----------
        size: std::vector< itkImageCVF33_Pointer >::size_type
        value: std::vector< itkImageCVF33_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageCVF33_swiginit(self, _itkImagePython.new_vectoritkImageCVF33(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF33_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF33_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF33_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF33_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF33_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF33_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF33_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF33_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageCVF33

# Register vectoritkImageCVF33 in _itkImagePython:
_itkImagePython.vectoritkImageCVF33_swigregister(vectoritkImageCVF33)

class vectoritkImageCVF43(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageCVF43_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF43_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF43___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF43___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF43___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF43___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF43___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF43___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF43___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF43___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF43___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF43_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF43_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF43_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF43_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF43_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF43_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF43_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF43_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF43_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF43_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF43_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF43_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF43_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageCVF43
        __init__(self, other) -> vectoritkImageCVF43

        Parameters
        ----------
        other: std::vector< itkImageCVF43_Pointer > const &

        __init__(self, size) -> vectoritkImageCVF43

        Parameters
        ----------
        size: std::vector< itkImageCVF43_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageCVF43

        Parameters
        ----------
        size: std::vector< itkImageCVF43_Pointer >::size_type
        value: std::vector< itkImageCVF43_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageCVF43_swiginit(self, _itkImagePython.new_vectoritkImageCVF43(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF43_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF43_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF43_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF43_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF43_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF43_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF43_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF43_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageCVF43

# Register vectoritkImageCVF43 in _itkImagePython:
_itkImagePython.vectoritkImageCVF43_swigregister(vectoritkImageCVF43)

class vectoritkImageSS3(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageSS3_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageSS3_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSS3___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSS3___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSS3___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSS3___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSS3___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSS3___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSS3___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSS3___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSS3___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageSS3_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageSS3_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageSS3_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageSS3_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageSS3_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageSS3_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageSS3_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageSS3_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageSS3_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageSS3_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageSS3_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageSS3_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageSS3_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageSS3
        __init__(self, other) -> vectoritkImageSS3

        Parameters
        ----------
        other: std::vector< itkImageSS3_Pointer > const &

        __init__(self, size) -> vectoritkImageSS3

        Parameters
        ----------
        size: std::vector< itkImageSS3_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageSS3

        Parameters
        ----------
        size: std::vector< itkImageSS3_Pointer >::size_type
        value: std::vector< itkImageSS3_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageSS3_swiginit(self, _itkImagePython.new_vectoritkImageSS3(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageSS3_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageSS3_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageSS3_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageSS3_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageSS3_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageSS3_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageSS3_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageSS3_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageSS3

# Register vectoritkImageSS3 in _itkImagePython:
_itkImagePython.vectoritkImageSS3_swigregister(vectoritkImageSS3)

class vectoritkImageUC3(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageUC3_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageUC3_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUC3___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUC3___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUC3___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUC3___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUC3___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUC3___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUC3___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUC3___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUC3___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageUC3_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageUC3_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageUC3_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageUC3_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageUC3_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageUC3_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageUC3_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageUC3_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageUC3_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageUC3_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageUC3_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageUC3_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageUC3_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageUC3
        __init__(self, other) -> vectoritkImageUC3

        Parameters
        ----------
        other: std::vector< itkImageUC3_Pointer > const &

        __init__(self, size) -> vectoritkImageUC3

        Parameters
        ----------
        size: std::vector< itkImageUC3_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageUC3

        Parameters
        ----------
        size: std::vector< itkImageUC3_Pointer >::size_type
        value: std::vector< itkImageUC3_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageUC3_swiginit(self, _itkImagePython.new_vectoritkImageUC3(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageUC3_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageUC3_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageUC3_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageUC3_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageUC3_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageUC3_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageUC3_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageUC3_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageUC3

# Register vectoritkImageUC3 in _itkImagePython:
_itkImagePython.vectoritkImageUC3_swigregister(vectoritkImageUC3)

class vectoritkImageUS3(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageUS3_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageUS3_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUS3___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUS3___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUS3___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUS3___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUS3___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUS3___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUS3___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUS3___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUS3___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageUS3_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageUS3_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageUS3_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageUS3_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageUS3_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageUS3_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageUS3_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageUS3_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageUS3_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageUS3_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageUS3_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageUS3_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageUS3_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageUS3
        __init__(self, other) -> vectoritkImageUS3

        Parameters
        ----------
        other: std::vector< itkImageUS3_Pointer > const &

        __init__(self, size) -> vectoritkImageUS3

        Parameters
        ----------
        size: std::vector< itkImageUS3_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageUS3

        Parameters
        ----------
        size: std::vector< itkImageUS3_Pointer >::size_type
        value: std::vector< itkImageUS3_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageUS3_swiginit(self, _itkImagePython.new_vectoritkImageUS3(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageUS3_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageUS3_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageUS3_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageUS3_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageUS3_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageUS3_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageUS3_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageUS3_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageUS3

# Register vectoritkImageUS3 in _itkImagePython:
_itkImagePython.vectoritkImageUS3_swigregister(vectoritkImageUS3)

class vectoritkImageF3(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageF3_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageF3_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageF3___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageF3___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageF3___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageF3___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageF3___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageF3___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageF3___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageF3___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageF3___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageF3_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageF3_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageF3_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageF3_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageF3_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageF3_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageF3_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageF3_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageF3_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageF3_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageF3_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageF3_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageF3_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageF3
        __init__(self, other) -> vectoritkImageF3

        Parameters
        ----------
        other: std::vector< itkImageF3_Pointer > const &

        __init__(self, size) -> vectoritkImageF3

        Parameters
        ----------
        size: std::vector< itkImageF3_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageF3

        Parameters
        ----------
        size: std::vector< itkImageF3_Pointer >::size_type
        value: std::vector< itkImageF3_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageF3_swiginit(self, _itkImagePython.new_vectoritkImageF3(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageF3_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageF3_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageF3_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageF3_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageF3_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageF3_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageF3_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageF3_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageF3

# Register vectoritkImageF3 in _itkImagePython:
_itkImagePython.vectoritkImageF3_swigregister(vectoritkImageF3)

class vectoritkImageD3(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageD3_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageD3_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageD3___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageD3___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageD3___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageD3___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageD3___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageD3___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageD3___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageD3___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageD3___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageD3_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageD3_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageD3_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageD3_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageD3_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageD3_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageD3_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageD3_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageD3_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageD3_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageD3_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageD3_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageD3_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageD3
        __init__(self, other) -> vectoritkImageD3

        Parameters
        ----------
        other: std::vector< itkImageD3_Pointer > const &

        __init__(self, size) -> vectoritkImageD3

        Parameters
        ----------
        size: std::vector< itkImageD3_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageD3

        Parameters
        ----------
        size: std::vector< itkImageD3_Pointer >::size_type
        value: std::vector< itkImageD3_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageD3_swiginit(self, _itkImagePython.new_vectoritkImageD3(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageD3_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageD3_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageD3_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageD3_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageD3_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageD3_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageD3_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageD3_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageD3

# Register vectoritkImageD3 in _itkImagePython:
_itkImagePython.vectoritkImageD3_swigregister(vectoritkImageD3)

class vectoritkImageCD3(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageCD3_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageCD3_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCD3___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCD3___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCD3___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCD3___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCD3___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCD3___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCD3___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCD3___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCD3___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageCD3_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageCD3_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageCD3_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageCD3_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageCD3_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageCD3_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageCD3_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageCD3_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageCD3_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageCD3_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageCD3_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageCD3_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageCD3_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageCD3
        __init__(self, other) -> vectoritkImageCD3

        Parameters
        ----------
        other: std::vector< itkImageCD3_Pointer > const &

        __init__(self, size) -> vectoritkImageCD3

        Parameters
        ----------
        size: std::vector< itkImageCD3_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageCD3

        Parameters
        ----------
        size: std::vector< itkImageCD3_Pointer >::size_type
        value: std::vector< itkImageCD3_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageCD3_swiginit(self, _itkImagePython.new_vectoritkImageCD3(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageCD3_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageCD3_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageCD3_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageCD3_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageCD3_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageCD3_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageCD3_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageCD3_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageCD3

# Register vectoritkImageCD3 in _itkImagePython:
_itkImagePython.vectoritkImageCD3_swigregister(vectoritkImageCD3)

class vectoritkImageCF3(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageCF3_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageCF3_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCF3___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCF3___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCF3___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCF3___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCF3___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCF3___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCF3___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCF3___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCF3___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageCF3_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageCF3_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageCF3_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageCF3_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageCF3_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageCF3_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageCF3_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageCF3_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageCF3_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageCF3_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageCF3_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageCF3_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageCF3_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageCF3
        __init__(self, other) -> vectoritkImageCF3

        Parameters
        ----------
        other: std::vector< itkImageCF3_Pointer > const &

        __init__(self, size) -> vectoritkImageCF3

        Parameters
        ----------
        size: std::vector< itkImageCF3_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageCF3

        Parameters
        ----------
        size: std::vector< itkImageCF3_Pointer >::size_type
        value: std::vector< itkImageCF3_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageCF3_swiginit(self, _itkImagePython.new_vectoritkImageCF3(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageCF3_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageCF3_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageCF3_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageCF3_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageCF3_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageCF3_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageCF3_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageCF3_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageCF3

# Register vectoritkImageCF3 in _itkImagePython:
_itkImagePython.vectoritkImageCF3_swigregister(vectoritkImageCF3)

class vectoritkImageVD23(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageVD23_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageVD23_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD23___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD23___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD23___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD23___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD23___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD23___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD23___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD23___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD23___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageVD23_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageVD23_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageVD23_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageVD23_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageVD23_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageVD23_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageVD23_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageVD23_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageVD23_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageVD23_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageVD23_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageVD23_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageVD23_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageVD23
        __init__(self, other) -> vectoritkImageVD23

        Parameters
        ----------
        other: std::vector< itkImageVD23_Pointer > const &

        __init__(self, size) -> vectoritkImageVD23

        Parameters
        ----------
        size: std::vector< itkImageVD23_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageVD23

        Parameters
        ----------
        size: std::vector< itkImageVD23_Pointer >::size_type
        value: std::vector< itkImageVD23_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageVD23_swiginit(self, _itkImagePython.new_vectoritkImageVD23(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageVD23_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageVD23_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageVD23_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageVD23_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageVD23_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageVD23_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageVD23_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageVD23_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageVD23

# Register vectoritkImageVD23 in _itkImagePython:
_itkImagePython.vectoritkImageVD23_swigregister(vectoritkImageVD23)

class vectoritkImageVD33(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageVD33_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageVD33_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD33___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD33___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD33___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD33___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD33___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD33___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD33___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD33___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD33___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageVD33_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageVD33_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageVD33_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageVD33_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageVD33_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageVD33_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageVD33_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageVD33_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageVD33_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageVD33_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageVD33_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageVD33_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageVD33_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageVD33
        __init__(self, other) -> vectoritkImageVD33

        Parameters
        ----------
        other: std::vector< itkImageVD33_Pointer > const &

        __init__(self, size) -> vectoritkImageVD33

        Parameters
        ----------
        size: std::vector< itkImageVD33_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageVD33

        Parameters
        ----------
        size: std::vector< itkImageVD33_Pointer >::size_type
        value: std::vector< itkImageVD33_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageVD33_swiginit(self, _itkImagePython.new_vectoritkImageVD33(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageVD33_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageVD33_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageVD33_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageVD33_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageVD33_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageVD33_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageVD33_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageVD33_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageVD33

# Register vectoritkImageVD33 in _itkImagePython:
_itkImagePython.vectoritkImageVD33_swigregister(vectoritkImageVD33)

class vectoritkImageVD43(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageVD43_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageVD43_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD43___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD43___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD43___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD43___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD43___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD43___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD43___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD43___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD43___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageVD43_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageVD43_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageVD43_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageVD43_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageVD43_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageVD43_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageVD43_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageVD43_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageVD43_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageVD43_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageVD43_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageVD43_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageVD43_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageVD43
        __init__(self, other) -> vectoritkImageVD43

        Parameters
        ----------
        other: std::vector< itkImageVD43_Pointer > const &

        __init__(self, size) -> vectoritkImageVD43

        Parameters
        ----------
        size: std::vector< itkImageVD43_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageVD43

        Parameters
        ----------
        size: std::vector< itkImageVD43_Pointer >::size_type
        value: std::vector< itkImageVD43_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageVD43_swiginit(self, _itkImagePython.new_vectoritkImageVD43(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageVD43_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageVD43_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageVD43_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageVD43_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageVD43_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageVD43_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageVD43_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageVD43_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageVD43

# Register vectoritkImageVD43 in _itkImagePython:
_itkImagePython.vectoritkImageVD43_swigregister(vectoritkImageVD43)

class vectoritkImageSI3(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageSI3_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageSI3_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSI3___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSI3___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSI3___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSI3___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSI3___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSI3___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSI3___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSI3___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSI3___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageSI3_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageSI3_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageSI3_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageSI3_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageSI3_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageSI3_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageSI3_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageSI3_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageSI3_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageSI3_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageSI3_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageSI3_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageSI3_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageSI3
        __init__(self, other) -> vectoritkImageSI3

        Parameters
        ----------
        other: std::vector< itkImageSI3_Pointer > const &

        __init__(self, size) -> vectoritkImageSI3

        Parameters
        ----------
        size: std::vector< itkImageSI3_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageSI3

        Parameters
        ----------
        size: std::vector< itkImageSI3_Pointer >::size_type
        value: std::vector< itkImageSI3_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageSI3_swiginit(self, _itkImagePython.new_vectoritkImageSI3(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageSI3_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageSI3_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageSI3_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageSI3_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageSI3_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageSI3_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageSI3_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageSI3_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageSI3

# Register vectoritkImageSI3 in _itkImagePython:
_itkImagePython.vectoritkImageSI3_swigregister(vectoritkImageSI3)

class vectoritkImageUI3(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageUI3_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageUI3_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUI3___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUI3___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUI3___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUI3___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUI3___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUI3___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUI3___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUI3___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUI3___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageUI3_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageUI3_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageUI3_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageUI3_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageUI3_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageUI3_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageUI3_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageUI3_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageUI3_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageUI3_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageUI3_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageUI3_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageUI3_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageUI3
        __init__(self, other) -> vectoritkImageUI3

        Parameters
        ----------
        other: std::vector< itkImageUI3_Pointer > const &

        __init__(self, size) -> vectoritkImageUI3

        Parameters
        ----------
        size: std::vector< itkImageUI3_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageUI3

        Parameters
        ----------
        size: std::vector< itkImageUI3_Pointer >::size_type
        value: std::vector< itkImageUI3_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageUI3_swiginit(self, _itkImagePython.new_vectoritkImageUI3(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageUI3_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageUI3_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageUI3_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageUI3_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageUI3_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageUI3_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageUI3_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageUI3_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageUI3

# Register vectoritkImageUI3 in _itkImagePython:
_itkImagePython.vectoritkImageUI3_swigregister(vectoritkImageUI3)

class vectoritkImageUL3(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageUL3_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageUL3_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUL3___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUL3___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUL3___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUL3___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUL3___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUL3___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUL3___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUL3___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUL3___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageUL3_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageUL3_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageUL3_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageUL3_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageUL3_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageUL3_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageUL3_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageUL3_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageUL3_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageUL3_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageUL3_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageUL3_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageUL3_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageUL3
        __init__(self, other) -> vectoritkImageUL3

        Parameters
        ----------
        other: std::vector< itkImageUL3_Pointer > const &

        __init__(self, size) -> vectoritkImageUL3

        Parameters
        ----------
        size: std::vector< itkImageUL3_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageUL3

        Parameters
        ----------
        size: std::vector< itkImageUL3_Pointer >::size_type
        value: std::vector< itkImageUL3_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageUL3_swiginit(self, _itkImagePython.new_vectoritkImageUL3(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageUL3_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageUL3_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageUL3_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageUL3_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageUL3_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageUL3_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageUL3_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageUL3_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageUL3

# Register vectoritkImageUL3 in _itkImagePython:
_itkImagePython.vectoritkImageUL3_swigregister(vectoritkImageUL3)

class vectoritkImageULL3(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageULL3_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageULL3_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageULL3___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageULL3___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageULL3___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageULL3___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageULL3___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageULL3___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageULL3___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageULL3___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageULL3___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageULL3_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageULL3_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageULL3_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageULL3_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageULL3_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageULL3_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageULL3_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageULL3_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageULL3_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageULL3_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageULL3_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageULL3_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageULL3_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageULL3
        __init__(self, other) -> vectoritkImageULL3

        Parameters
        ----------
        other: std::vector< itkImageULL3_Pointer > const &

        __init__(self, size) -> vectoritkImageULL3

        Parameters
        ----------
        size: std::vector< itkImageULL3_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageULL3

        Parameters
        ----------
        size: std::vector< itkImageULL3_Pointer >::size_type
        value: std::vector< itkImageULL3_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageULL3_swiginit(self, _itkImagePython.new_vectoritkImageULL3(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageULL3_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageULL3_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageULL3_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageULL3_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageULL3_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageULL3_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageULL3_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageULL3_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageULL3

# Register vectoritkImageULL3 in _itkImagePython:
_itkImagePython.vectoritkImageULL3_swigregister(vectoritkImageULL3)

class vectoritkImageB3(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageB3_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageB3_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageB3___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageB3___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageB3___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageB3___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageB3___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageB3___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageB3___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageB3___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageB3___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageB3_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageB3_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageB3_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageB3_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageB3_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageB3_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageB3_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageB3_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageB3_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageB3_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageB3_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageB3_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageB3_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageB3
        __init__(self, other) -> vectoritkImageB3

        Parameters
        ----------
        other: std::vector< itkImageB3_Pointer > const &

        __init__(self, size) -> vectoritkImageB3

        Parameters
        ----------
        size: std::vector< itkImageB3_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageB3

        Parameters
        ----------
        size: std::vector< itkImageB3_Pointer >::size_type
        value: std::vector< itkImageB3_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageB3_swiginit(self, _itkImagePython.new_vectoritkImageB3(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageB3_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageB3_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageB3_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageB3_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageB3_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageB3_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageB3_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageB3_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageB3

# Register vectoritkImageB3 in _itkImagePython:
_itkImagePython.vectoritkImageB3_swigregister(vectoritkImageB3)

class vectoritkImageFAF33(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageFAF33_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF33_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF33___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF33___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF33___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF33___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF33___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF33___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF33___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF33___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF33___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF33_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF33_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF33_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF33_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF33_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF33_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF33_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF33_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF33_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF33_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF33_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF33_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF33_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageFAF33
        __init__(self, other) -> vectoritkImageFAF33

        Parameters
        ----------
        other: std::vector< itkImageFAF33_Pointer > const &

        __init__(self, size) -> vectoritkImageFAF33

        Parameters
        ----------
        size: std::vector< itkImageFAF33_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageFAF33

        Parameters
        ----------
        size: std::vector< itkImageFAF33_Pointer >::size_type
        value: std::vector< itkImageFAF33_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageFAF33_swiginit(self, _itkImagePython.new_vectoritkImageFAF33(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF33_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF33_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF33_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF33_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF33_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF33_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF33_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF33_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageFAF33

# Register vectoritkImageFAF33 in _itkImagePython:
_itkImagePython.vectoritkImageFAF33_swigregister(vectoritkImageFAF33)

class vectoritkImageFAD33(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageFAD33_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD33_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD33___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD33___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD33___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD33___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD33___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD33___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD33___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD33___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD33___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD33_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD33_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD33_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD33_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD33_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD33_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD33_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD33_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD33_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD33_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD33_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD33_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD33_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageFAD33
        __init__(self, other) -> vectoritkImageFAD33

        Parameters
        ----------
        other: std::vector< itkImageFAD33_Pointer > const &

        __init__(self, size) -> vectoritkImageFAD33

        Parameters
        ----------
        size: std::vector< itkImageFAD33_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageFAD33

        Parameters
        ----------
        size: std::vector< itkImageFAD33_Pointer >::size_type
        value: std::vector< itkImageFAD33_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageFAD33_swiginit(self, _itkImagePython.new_vectoritkImageFAD33(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD33_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD33_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD33_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD33_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD33_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD33_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD33_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD33_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageFAD33

# Register vectoritkImageFAD33 in _itkImagePython:
_itkImagePython.vectoritkImageFAD33_swigregister(vectoritkImageFAD33)

class vectoritkImageO33(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageO33_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageO33_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageO33___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageO33___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageO33___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageO33___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageO33___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageO33___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageO33___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageO33___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageO33___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageO33_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageO33_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageO33_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageO33_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageO33_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageO33_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageO33_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageO33_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageO33_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageO33_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageO33_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageO33_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageO33_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageO33
        __init__(self, other) -> vectoritkImageO33

        Parameters
        ----------
        other: std::vector< itkImageO33_Pointer > const &

        __init__(self, size) -> vectoritkImageO33

        Parameters
        ----------
        size: std::vector< itkImageO33_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageO33

        Parameters
        ----------
        size: std::vector< itkImageO33_Pointer >::size_type
        value: std::vector< itkImageO33_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageO33_swiginit(self, _itkImagePython.new_vectoritkImageO33(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageO33_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageO33_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageO33_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageO33_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageO33_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageO33_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageO33_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageO33_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageO33

# Register vectoritkImageO33 in _itkImagePython:
_itkImagePython.vectoritkImageO33_swigregister(vectoritkImageO33)

class vectoritkImageSSRTD33(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageSSRTD33_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD33_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD33___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD33___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD33___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD33___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD33___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD33___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD33___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD33___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD33___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD33_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD33_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD33_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD33_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD33_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD33_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD33_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD33_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD33_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD33_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD33_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD33_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD33_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageSSRTD33
        __init__(self, other) -> vectoritkImageSSRTD33

        Parameters
        ----------
        other: std::vector< itkImageSSRTD33_Pointer > const &

        __init__(self, size) -> vectoritkImageSSRTD33

        Parameters
        ----------
        size: std::vector< itkImageSSRTD33_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageSSRTD33

        Parameters
        ----------
        size: std::vector< itkImageSSRTD33_Pointer >::size_type
        value: std::vector< itkImageSSRTD33_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageSSRTD33_swiginit(self, _itkImagePython.new_vectoritkImageSSRTD33(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD33_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD33_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD33_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD33_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD33_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD33_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD33_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD33_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageSSRTD33

# Register vectoritkImageSSRTD33 in _itkImagePython:
_itkImagePython.vectoritkImageSSRTD33_swigregister(vectoritkImageSSRTD33)

class vectoritkImageRGBUC4(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageRGBUC4_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC4_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC4___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC4___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC4___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC4___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC4___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC4___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC4___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC4___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC4___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC4_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC4_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC4_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC4_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC4_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC4_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC4_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC4_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC4_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC4_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC4_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC4_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC4_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageRGBUC4
        __init__(self, other) -> vectoritkImageRGBUC4

        Parameters
        ----------
        other: std::vector< itkImageRGBUC4_Pointer > const &

        __init__(self, size) -> vectoritkImageRGBUC4

        Parameters
        ----------
        size: std::vector< itkImageRGBUC4_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageRGBUC4

        Parameters
        ----------
        size: std::vector< itkImageRGBUC4_Pointer >::size_type
        value: std::vector< itkImageRGBUC4_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageRGBUC4_swiginit(self, _itkImagePython.new_vectoritkImageRGBUC4(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC4_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC4_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC4_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC4_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC4_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC4_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC4_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBUC4_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageRGBUC4

# Register vectoritkImageRGBUC4 in _itkImagePython:
_itkImagePython.vectoritkImageRGBUC4_swigregister(vectoritkImageRGBUC4)

class vectoritkImageRGBAUC4(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageRGBAUC4_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC4_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC4___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC4___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC4___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC4___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC4___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC4___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC4___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC4___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC4___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC4_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC4_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC4_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC4_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC4_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC4_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC4_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC4_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC4_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC4_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC4_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC4_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC4_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageRGBAUC4
        __init__(self, other) -> vectoritkImageRGBAUC4

        Parameters
        ----------
        other: std::vector< itkImageRGBAUC4_Pointer > const &

        __init__(self, size) -> vectoritkImageRGBAUC4

        Parameters
        ----------
        size: std::vector< itkImageRGBAUC4_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageRGBAUC4

        Parameters
        ----------
        size: std::vector< itkImageRGBAUC4_Pointer >::size_type
        value: std::vector< itkImageRGBAUC4_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageRGBAUC4_swiginit(self, _itkImagePython.new_vectoritkImageRGBAUC4(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC4_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC4_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC4_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC4_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC4_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC4_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC4_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageRGBAUC4_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageRGBAUC4

# Register vectoritkImageRGBAUC4 in _itkImagePython:
_itkImagePython.vectoritkImageRGBAUC4_swigregister(vectoritkImageRGBAUC4)

class vectoritkImageVF24(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageVF24_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageVF24_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF24___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF24___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF24___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF24___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF24___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF24___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF24___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF24___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF24___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageVF24_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageVF24_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageVF24_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageVF24_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageVF24_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageVF24_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageVF24_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageVF24_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageVF24_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageVF24_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageVF24_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageVF24_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageVF24_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageVF24
        __init__(self, other) -> vectoritkImageVF24

        Parameters
        ----------
        other: std::vector< itkImageVF24_Pointer > const &

        __init__(self, size) -> vectoritkImageVF24

        Parameters
        ----------
        size: std::vector< itkImageVF24_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageVF24

        Parameters
        ----------
        size: std::vector< itkImageVF24_Pointer >::size_type
        value: std::vector< itkImageVF24_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageVF24_swiginit(self, _itkImagePython.new_vectoritkImageVF24(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageVF24_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageVF24_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageVF24_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageVF24_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageVF24_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageVF24_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageVF24_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageVF24_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageVF24

# Register vectoritkImageVF24 in _itkImagePython:
_itkImagePython.vectoritkImageVF24_swigregister(vectoritkImageVF24)

class vectoritkImageVF34(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageVF34_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageVF34_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF34___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF34___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF34___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF34___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF34___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF34___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF34___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF34___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF34___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageVF34_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageVF34_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageVF34_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageVF34_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageVF34_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageVF34_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageVF34_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageVF34_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageVF34_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageVF34_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageVF34_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageVF34_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageVF34_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageVF34
        __init__(self, other) -> vectoritkImageVF34

        Parameters
        ----------
        other: std::vector< itkImageVF34_Pointer > const &

        __init__(self, size) -> vectoritkImageVF34

        Parameters
        ----------
        size: std::vector< itkImageVF34_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageVF34

        Parameters
        ----------
        size: std::vector< itkImageVF34_Pointer >::size_type
        value: std::vector< itkImageVF34_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageVF34_swiginit(self, _itkImagePython.new_vectoritkImageVF34(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageVF34_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageVF34_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageVF34_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageVF34_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageVF34_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageVF34_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageVF34_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageVF34_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageVF34

# Register vectoritkImageVF34 in _itkImagePython:
_itkImagePython.vectoritkImageVF34_swigregister(vectoritkImageVF34)

class vectoritkImageVF44(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageVF44_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageVF44_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF44___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF44___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF44___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF44___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF44___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF44___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF44___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF44___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF44___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageVF44_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageVF44_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageVF44_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageVF44_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageVF44_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageVF44_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageVF44_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageVF44_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageVF44_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageVF44_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageVF44_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageVF44_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageVF44_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageVF44
        __init__(self, other) -> vectoritkImageVF44

        Parameters
        ----------
        other: std::vector< itkImageVF44_Pointer > const &

        __init__(self, size) -> vectoritkImageVF44

        Parameters
        ----------
        size: std::vector< itkImageVF44_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageVF44

        Parameters
        ----------
        size: std::vector< itkImageVF44_Pointer >::size_type
        value: std::vector< itkImageVF44_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageVF44_swiginit(self, _itkImagePython.new_vectoritkImageVF44(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageVF44_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageVF44_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageVF44_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageVF44_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageVF44_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageVF44_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageVF44_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageVF44_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageVF44

# Register vectoritkImageVF44 in _itkImagePython:
_itkImagePython.vectoritkImageVF44_swigregister(vectoritkImageVF44)

class vectoritkImageCVF24(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageCVF24_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF24_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF24___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF24___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF24___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF24___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF24___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF24___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF24___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF24___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF24___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF24_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF24_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF24_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF24_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF24_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF24_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF24_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF24_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF24_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF24_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF24_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF24_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF24_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageCVF24
        __init__(self, other) -> vectoritkImageCVF24

        Parameters
        ----------
        other: std::vector< itkImageCVF24_Pointer > const &

        __init__(self, size) -> vectoritkImageCVF24

        Parameters
        ----------
        size: std::vector< itkImageCVF24_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageCVF24

        Parameters
        ----------
        size: std::vector< itkImageCVF24_Pointer >::size_type
        value: std::vector< itkImageCVF24_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageCVF24_swiginit(self, _itkImagePython.new_vectoritkImageCVF24(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF24_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF24_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF24_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF24_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF24_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF24_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF24_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF24_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageCVF24

# Register vectoritkImageCVF24 in _itkImagePython:
_itkImagePython.vectoritkImageCVF24_swigregister(vectoritkImageCVF24)

class vectoritkImageCVF34(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageCVF34_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF34_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF34___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF34___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF34___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF34___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF34___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF34___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF34___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF34___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF34___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF34_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF34_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF34_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF34_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF34_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF34_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF34_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF34_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF34_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF34_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF34_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF34_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF34_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageCVF34
        __init__(self, other) -> vectoritkImageCVF34

        Parameters
        ----------
        other: std::vector< itkImageCVF34_Pointer > const &

        __init__(self, size) -> vectoritkImageCVF34

        Parameters
        ----------
        size: std::vector< itkImageCVF34_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageCVF34

        Parameters
        ----------
        size: std::vector< itkImageCVF34_Pointer >::size_type
        value: std::vector< itkImageCVF34_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageCVF34_swiginit(self, _itkImagePython.new_vectoritkImageCVF34(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF34_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF34_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF34_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF34_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF34_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF34_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF34_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF34_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageCVF34

# Register vectoritkImageCVF34 in _itkImagePython:
_itkImagePython.vectoritkImageCVF34_swigregister(vectoritkImageCVF34)

class vectoritkImageCVF44(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageCVF44_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF44_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF44___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF44___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF44___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF44___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF44___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF44___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF44___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF44___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF44___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF44_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF44_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF44_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF44_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF44_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF44_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF44_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF44_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF44_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF44_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF44_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF44_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF44_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageCVF44
        __init__(self, other) -> vectoritkImageCVF44

        Parameters
        ----------
        other: std::vector< itkImageCVF44_Pointer > const &

        __init__(self, size) -> vectoritkImageCVF44

        Parameters
        ----------
        size: std::vector< itkImageCVF44_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageCVF44

        Parameters
        ----------
        size: std::vector< itkImageCVF44_Pointer >::size_type
        value: std::vector< itkImageCVF44_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageCVF44_swiginit(self, _itkImagePython.new_vectoritkImageCVF44(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF44_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF44_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF44_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF44_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF44_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF44_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF44_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageCVF44_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageCVF44

# Register vectoritkImageCVF44 in _itkImagePython:
_itkImagePython.vectoritkImageCVF44_swigregister(vectoritkImageCVF44)

class vectoritkImageSS4(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageSS4_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageSS4_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSS4___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSS4___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSS4___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSS4___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSS4___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSS4___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSS4___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSS4___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSS4___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageSS4_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageSS4_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageSS4_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageSS4_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageSS4_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageSS4_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageSS4_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageSS4_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageSS4_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageSS4_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageSS4_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageSS4_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageSS4_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageSS4
        __init__(self, other) -> vectoritkImageSS4

        Parameters
        ----------
        other: std::vector< itkImageSS4_Pointer > const &

        __init__(self, size) -> vectoritkImageSS4

        Parameters
        ----------
        size: std::vector< itkImageSS4_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageSS4

        Parameters
        ----------
        size: std::vector< itkImageSS4_Pointer >::size_type
        value: std::vector< itkImageSS4_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageSS4_swiginit(self, _itkImagePython.new_vectoritkImageSS4(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageSS4_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageSS4_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageSS4_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageSS4_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageSS4_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageSS4_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageSS4_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageSS4_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageSS4

# Register vectoritkImageSS4 in _itkImagePython:
_itkImagePython.vectoritkImageSS4_swigregister(vectoritkImageSS4)

class vectoritkImageUC4(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageUC4_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageUC4_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUC4___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUC4___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUC4___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUC4___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUC4___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUC4___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUC4___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUC4___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUC4___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageUC4_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageUC4_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageUC4_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageUC4_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageUC4_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageUC4_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageUC4_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageUC4_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageUC4_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageUC4_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageUC4_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageUC4_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageUC4_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageUC4
        __init__(self, other) -> vectoritkImageUC4

        Parameters
        ----------
        other: std::vector< itkImageUC4_Pointer > const &

        __init__(self, size) -> vectoritkImageUC4

        Parameters
        ----------
        size: std::vector< itkImageUC4_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageUC4

        Parameters
        ----------
        size: std::vector< itkImageUC4_Pointer >::size_type
        value: std::vector< itkImageUC4_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageUC4_swiginit(self, _itkImagePython.new_vectoritkImageUC4(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageUC4_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageUC4_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageUC4_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageUC4_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageUC4_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageUC4_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageUC4_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageUC4_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageUC4

# Register vectoritkImageUC4 in _itkImagePython:
_itkImagePython.vectoritkImageUC4_swigregister(vectoritkImageUC4)

class vectoritkImageUS4(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageUS4_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageUS4_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUS4___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUS4___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUS4___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUS4___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUS4___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUS4___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUS4___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUS4___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUS4___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageUS4_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageUS4_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageUS4_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageUS4_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageUS4_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageUS4_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageUS4_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageUS4_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageUS4_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageUS4_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageUS4_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageUS4_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageUS4_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageUS4
        __init__(self, other) -> vectoritkImageUS4

        Parameters
        ----------
        other: std::vector< itkImageUS4_Pointer > const &

        __init__(self, size) -> vectoritkImageUS4

        Parameters
        ----------
        size: std::vector< itkImageUS4_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageUS4

        Parameters
        ----------
        size: std::vector< itkImageUS4_Pointer >::size_type
        value: std::vector< itkImageUS4_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageUS4_swiginit(self, _itkImagePython.new_vectoritkImageUS4(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageUS4_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageUS4_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageUS4_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageUS4_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageUS4_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageUS4_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageUS4_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageUS4_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageUS4

# Register vectoritkImageUS4 in _itkImagePython:
_itkImagePython.vectoritkImageUS4_swigregister(vectoritkImageUS4)

class vectoritkImageF4(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageF4_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageF4_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageF4___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageF4___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageF4___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageF4___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageF4___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageF4___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageF4___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageF4___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageF4___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageF4_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageF4_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageF4_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageF4_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageF4_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageF4_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageF4_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageF4_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageF4_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageF4_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageF4_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageF4_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageF4_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageF4
        __init__(self, other) -> vectoritkImageF4

        Parameters
        ----------
        other: std::vector< itkImageF4_Pointer > const &

        __init__(self, size) -> vectoritkImageF4

        Parameters
        ----------
        size: std::vector< itkImageF4_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageF4

        Parameters
        ----------
        size: std::vector< itkImageF4_Pointer >::size_type
        value: std::vector< itkImageF4_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageF4_swiginit(self, _itkImagePython.new_vectoritkImageF4(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageF4_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageF4_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageF4_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageF4_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageF4_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageF4_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageF4_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageF4_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageF4

# Register vectoritkImageF4 in _itkImagePython:
_itkImagePython.vectoritkImageF4_swigregister(vectoritkImageF4)

class vectoritkImageD4(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageD4_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageD4_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageD4___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageD4___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageD4___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageD4___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageD4___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageD4___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageD4___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageD4___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageD4___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageD4_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageD4_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageD4_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageD4_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageD4_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageD4_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageD4_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageD4_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageD4_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageD4_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageD4_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageD4_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageD4_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageD4
        __init__(self, other) -> vectoritkImageD4

        Parameters
        ----------
        other: std::vector< itkImageD4_Pointer > const &

        __init__(self, size) -> vectoritkImageD4

        Parameters
        ----------
        size: std::vector< itkImageD4_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageD4

        Parameters
        ----------
        size: std::vector< itkImageD4_Pointer >::size_type
        value: std::vector< itkImageD4_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageD4_swiginit(self, _itkImagePython.new_vectoritkImageD4(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageD4_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageD4_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageD4_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageD4_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageD4_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageD4_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageD4_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageD4_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageD4

# Register vectoritkImageD4 in _itkImagePython:
_itkImagePython.vectoritkImageD4_swigregister(vectoritkImageD4)

class vectoritkImageCD4(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageCD4_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageCD4_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCD4___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCD4___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCD4___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCD4___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCD4___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCD4___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCD4___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCD4___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCD4___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageCD4_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageCD4_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageCD4_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageCD4_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageCD4_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageCD4_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageCD4_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageCD4_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageCD4_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageCD4_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageCD4_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageCD4_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageCD4_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageCD4
        __init__(self, other) -> vectoritkImageCD4

        Parameters
        ----------
        other: std::vector< itkImageCD4_Pointer > const &

        __init__(self, size) -> vectoritkImageCD4

        Parameters
        ----------
        size: std::vector< itkImageCD4_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageCD4

        Parameters
        ----------
        size: std::vector< itkImageCD4_Pointer >::size_type
        value: std::vector< itkImageCD4_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageCD4_swiginit(self, _itkImagePython.new_vectoritkImageCD4(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageCD4_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageCD4_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageCD4_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageCD4_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageCD4_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageCD4_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageCD4_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageCD4_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageCD4

# Register vectoritkImageCD4 in _itkImagePython:
_itkImagePython.vectoritkImageCD4_swigregister(vectoritkImageCD4)

class vectoritkImageCF4(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageCF4_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageCF4_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCF4___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCF4___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCF4___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCF4___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCF4___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCF4___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCF4___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCF4___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCF4___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageCF4_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageCF4_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageCF4_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageCF4_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageCF4_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageCF4_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageCF4_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageCF4_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageCF4_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageCF4_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageCF4_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageCF4_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageCF4_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageCF4
        __init__(self, other) -> vectoritkImageCF4

        Parameters
        ----------
        other: std::vector< itkImageCF4_Pointer > const &

        __init__(self, size) -> vectoritkImageCF4

        Parameters
        ----------
        size: std::vector< itkImageCF4_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageCF4

        Parameters
        ----------
        size: std::vector< itkImageCF4_Pointer >::size_type
        value: std::vector< itkImageCF4_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageCF4_swiginit(self, _itkImagePython.new_vectoritkImageCF4(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageCF4_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageCF4_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageCF4_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageCF4_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageCF4_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageCF4_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageCF4_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageCF4_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageCF4

# Register vectoritkImageCF4 in _itkImagePython:
_itkImagePython.vectoritkImageCF4_swigregister(vectoritkImageCF4)

class vectoritkImageVD24(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageVD24_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageVD24_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD24___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD24___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD24___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD24___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD24___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD24___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD24___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD24___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD24___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageVD24_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageVD24_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageVD24_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageVD24_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageVD24_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageVD24_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageVD24_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageVD24_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageVD24_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageVD24_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageVD24_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageVD24_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageVD24_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageVD24
        __init__(self, other) -> vectoritkImageVD24

        Parameters
        ----------
        other: std::vector< itkImageVD24_Pointer > const &

        __init__(self, size) -> vectoritkImageVD24

        Parameters
        ----------
        size: std::vector< itkImageVD24_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageVD24

        Parameters
        ----------
        size: std::vector< itkImageVD24_Pointer >::size_type
        value: std::vector< itkImageVD24_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageVD24_swiginit(self, _itkImagePython.new_vectoritkImageVD24(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageVD24_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageVD24_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageVD24_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageVD24_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageVD24_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageVD24_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageVD24_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageVD24_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageVD24

# Register vectoritkImageVD24 in _itkImagePython:
_itkImagePython.vectoritkImageVD24_swigregister(vectoritkImageVD24)

class vectoritkImageVD34(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageVD34_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageVD34_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD34___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD34___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD34___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD34___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD34___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD34___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD34___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD34___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD34___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageVD34_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageVD34_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageVD34_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageVD34_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageVD34_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageVD34_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageVD34_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageVD34_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageVD34_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageVD34_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageVD34_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageVD34_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageVD34_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageVD34
        __init__(self, other) -> vectoritkImageVD34

        Parameters
        ----------
        other: std::vector< itkImageVD34_Pointer > const &

        __init__(self, size) -> vectoritkImageVD34

        Parameters
        ----------
        size: std::vector< itkImageVD34_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageVD34

        Parameters
        ----------
        size: std::vector< itkImageVD34_Pointer >::size_type
        value: std::vector< itkImageVD34_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageVD34_swiginit(self, _itkImagePython.new_vectoritkImageVD34(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageVD34_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageVD34_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageVD34_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageVD34_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageVD34_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageVD34_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageVD34_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageVD34_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageVD34

# Register vectoritkImageVD34 in _itkImagePython:
_itkImagePython.vectoritkImageVD34_swigregister(vectoritkImageVD34)

class vectoritkImageVD44(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageVD44_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageVD44_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD44___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD44___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD44___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD44___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD44___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD44___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD44___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD44___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD44___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageVD44_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageVD44_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageVD44_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageVD44_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageVD44_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageVD44_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageVD44_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageVD44_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageVD44_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageVD44_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageVD44_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageVD44_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageVD44_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageVD44
        __init__(self, other) -> vectoritkImageVD44

        Parameters
        ----------
        other: std::vector< itkImageVD44_Pointer > const &

        __init__(self, size) -> vectoritkImageVD44

        Parameters
        ----------
        size: std::vector< itkImageVD44_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageVD44

        Parameters
        ----------
        size: std::vector< itkImageVD44_Pointer >::size_type
        value: std::vector< itkImageVD44_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageVD44_swiginit(self, _itkImagePython.new_vectoritkImageVD44(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageVD44_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageVD44_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageVD44_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageVD44_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageVD44_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageVD44_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageVD44_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageVD44_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageVD44

# Register vectoritkImageVD44 in _itkImagePython:
_itkImagePython.vectoritkImageVD44_swigregister(vectoritkImageVD44)

class vectoritkImageSI4(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageSI4_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageSI4_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSI4___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSI4___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSI4___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSI4___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSI4___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSI4___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSI4___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSI4___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSI4___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageSI4_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageSI4_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageSI4_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageSI4_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageSI4_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageSI4_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageSI4_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageSI4_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageSI4_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageSI4_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageSI4_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageSI4_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageSI4_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageSI4
        __init__(self, other) -> vectoritkImageSI4

        Parameters
        ----------
        other: std::vector< itkImageSI4_Pointer > const &

        __init__(self, size) -> vectoritkImageSI4

        Parameters
        ----------
        size: std::vector< itkImageSI4_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageSI4

        Parameters
        ----------
        size: std::vector< itkImageSI4_Pointer >::size_type
        value: std::vector< itkImageSI4_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageSI4_swiginit(self, _itkImagePython.new_vectoritkImageSI4(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageSI4_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageSI4_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageSI4_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageSI4_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageSI4_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageSI4_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageSI4_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageSI4_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageSI4

# Register vectoritkImageSI4 in _itkImagePython:
_itkImagePython.vectoritkImageSI4_swigregister(vectoritkImageSI4)

class vectoritkImageUI4(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageUI4_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageUI4_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUI4___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUI4___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUI4___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUI4___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUI4___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUI4___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUI4___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUI4___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUI4___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageUI4_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageUI4_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageUI4_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageUI4_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageUI4_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageUI4_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageUI4_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageUI4_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageUI4_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageUI4_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageUI4_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageUI4_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageUI4_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageUI4
        __init__(self, other) -> vectoritkImageUI4

        Parameters
        ----------
        other: std::vector< itkImageUI4_Pointer > const &

        __init__(self, size) -> vectoritkImageUI4

        Parameters
        ----------
        size: std::vector< itkImageUI4_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageUI4

        Parameters
        ----------
        size: std::vector< itkImageUI4_Pointer >::size_type
        value: std::vector< itkImageUI4_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageUI4_swiginit(self, _itkImagePython.new_vectoritkImageUI4(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageUI4_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageUI4_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageUI4_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageUI4_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageUI4_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageUI4_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageUI4_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageUI4_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageUI4

# Register vectoritkImageUI4 in _itkImagePython:
_itkImagePython.vectoritkImageUI4_swigregister(vectoritkImageUI4)

class vectoritkImageUL4(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageUL4_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageUL4_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUL4___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUL4___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUL4___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUL4___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUL4___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUL4___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUL4___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUL4___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageUL4___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageUL4_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageUL4_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageUL4_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageUL4_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageUL4_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageUL4_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageUL4_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageUL4_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageUL4_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageUL4_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageUL4_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageUL4_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageUL4_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageUL4
        __init__(self, other) -> vectoritkImageUL4

        Parameters
        ----------
        other: std::vector< itkImageUL4_Pointer > const &

        __init__(self, size) -> vectoritkImageUL4

        Parameters
        ----------
        size: std::vector< itkImageUL4_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageUL4

        Parameters
        ----------
        size: std::vector< itkImageUL4_Pointer >::size_type
        value: std::vector< itkImageUL4_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageUL4_swiginit(self, _itkImagePython.new_vectoritkImageUL4(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageUL4_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageUL4_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageUL4_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageUL4_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageUL4_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageUL4_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageUL4_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageUL4_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageUL4

# Register vectoritkImageUL4 in _itkImagePython:
_itkImagePython.vectoritkImageUL4_swigregister(vectoritkImageUL4)

class vectoritkImageULL4(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageULL4_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageULL4_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageULL4___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageULL4___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageULL4___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageULL4___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageULL4___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageULL4___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageULL4___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageULL4___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageULL4___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageULL4_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageULL4_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageULL4_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageULL4_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageULL4_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageULL4_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageULL4_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageULL4_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageULL4_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageULL4_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageULL4_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageULL4_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageULL4_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageULL4
        __init__(self, other) -> vectoritkImageULL4

        Parameters
        ----------
        other: std::vector< itkImageULL4_Pointer > const &

        __init__(self, size) -> vectoritkImageULL4

        Parameters
        ----------
        size: std::vector< itkImageULL4_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageULL4

        Parameters
        ----------
        size: std::vector< itkImageULL4_Pointer >::size_type
        value: std::vector< itkImageULL4_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageULL4_swiginit(self, _itkImagePython.new_vectoritkImageULL4(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageULL4_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageULL4_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageULL4_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageULL4_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageULL4_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageULL4_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageULL4_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageULL4_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageULL4

# Register vectoritkImageULL4 in _itkImagePython:
_itkImagePython.vectoritkImageULL4_swigregister(vectoritkImageULL4)

class vectoritkImageB4(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageB4_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageB4_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageB4___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageB4___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageB4___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageB4___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageB4___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageB4___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageB4___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageB4___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageB4___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageB4_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageB4_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageB4_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageB4_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageB4_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageB4_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageB4_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageB4_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageB4_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageB4_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageB4_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageB4_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageB4_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageB4
        __init__(self, other) -> vectoritkImageB4

        Parameters
        ----------
        other: std::vector< itkImageB4_Pointer > const &

        __init__(self, size) -> vectoritkImageB4

        Parameters
        ----------
        size: std::vector< itkImageB4_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageB4

        Parameters
        ----------
        size: std::vector< itkImageB4_Pointer >::size_type
        value: std::vector< itkImageB4_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageB4_swiginit(self, _itkImagePython.new_vectoritkImageB4(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageB4_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageB4_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageB4_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageB4_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageB4_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageB4_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageB4_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageB4_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageB4

# Register vectoritkImageB4 in _itkImagePython:
_itkImagePython.vectoritkImageB4_swigregister(vectoritkImageB4)

class vectoritkImageFAF44(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageFAF44_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF44_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF44___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF44___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF44___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF44___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF44___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF44___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF44___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF44___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF44___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF44_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF44_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF44_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF44_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF44_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF44_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF44_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF44_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF44_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF44_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF44_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF44_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF44_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageFAF44
        __init__(self, other) -> vectoritkImageFAF44

        Parameters
        ----------
        other: std::vector< itkImageFAF44_Pointer > const &

        __init__(self, size) -> vectoritkImageFAF44

        Parameters
        ----------
        size: std::vector< itkImageFAF44_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageFAF44

        Parameters
        ----------
        size: std::vector< itkImageFAF44_Pointer >::size_type
        value: std::vector< itkImageFAF44_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageFAF44_swiginit(self, _itkImagePython.new_vectoritkImageFAF44(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF44_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF44_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF44_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF44_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF44_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF44_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF44_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageFAF44_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageFAF44

# Register vectoritkImageFAF44 in _itkImagePython:
_itkImagePython.vectoritkImageFAF44_swigregister(vectoritkImageFAF44)

class vectoritkImageFAD44(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageFAD44_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD44_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD44___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD44___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD44___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD44___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD44___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD44___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD44___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD44___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD44___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD44_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD44_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD44_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD44_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD44_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD44_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD44_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD44_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD44_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD44_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD44_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD44_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD44_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageFAD44
        __init__(self, other) -> vectoritkImageFAD44

        Parameters
        ----------
        other: std::vector< itkImageFAD44_Pointer > const &

        __init__(self, size) -> vectoritkImageFAD44

        Parameters
        ----------
        size: std::vector< itkImageFAD44_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageFAD44

        Parameters
        ----------
        size: std::vector< itkImageFAD44_Pointer >::size_type
        value: std::vector< itkImageFAD44_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageFAD44_swiginit(self, _itkImagePython.new_vectoritkImageFAD44(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD44_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD44_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD44_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD44_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD44_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD44_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD44_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageFAD44_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageFAD44

# Register vectoritkImageFAD44 in _itkImagePython:
_itkImagePython.vectoritkImageFAD44_swigregister(vectoritkImageFAD44)

class vectoritkImageO44(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageO44_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageO44_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageO44___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageO44___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageO44___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageO44___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageO44___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageO44___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageO44___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageO44___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageO44___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageO44_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageO44_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageO44_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageO44_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageO44_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageO44_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageO44_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageO44_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageO44_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageO44_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageO44_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageO44_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageO44_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageO44
        __init__(self, other) -> vectoritkImageO44

        Parameters
        ----------
        other: std::vector< itkImageO44_Pointer > const &

        __init__(self, size) -> vectoritkImageO44

        Parameters
        ----------
        size: std::vector< itkImageO44_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageO44

        Parameters
        ----------
        size: std::vector< itkImageO44_Pointer >::size_type
        value: std::vector< itkImageO44_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageO44_swiginit(self, _itkImagePython.new_vectoritkImageO44(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageO44_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageO44_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageO44_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageO44_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageO44_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageO44_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageO44_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageO44_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageO44

# Register vectoritkImageO44 in _itkImagePython:
_itkImagePython.vectoritkImageO44_swigregister(vectoritkImageO44)

class vectoritkImageSSRTD44(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageSSRTD44_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD44_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD44___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD44___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD44___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD44___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD44___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD44___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD44___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD44___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD44___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD44_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD44_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD44_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD44_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD44_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD44_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD44_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD44_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD44_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD44_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD44_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD44_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD44_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageSSRTD44
        __init__(self, other) -> vectoritkImageSSRTD44

        Parameters
        ----------
        other: std::vector< itkImageSSRTD44_Pointer > const &

        __init__(self, size) -> vectoritkImageSSRTD44

        Parameters
        ----------
        size: std::vector< itkImageSSRTD44_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageSSRTD44

        Parameters
        ----------
        size: std::vector< itkImageSSRTD44_Pointer >::size_type
        value: std::vector< itkImageSSRTD44_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageSSRTD44_swiginit(self, _itkImagePython.new_vectoritkImageSSRTD44(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD44_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD44_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD44_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD44_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD44_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD44_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD44_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageSSRTD44_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageSSRTD44

# Register vectoritkImageSSRTD44 in _itkImagePython:
_itkImagePython.vectoritkImageSSRTD44_swigregister(vectoritkImageSSRTD44)

class vectoritkImageVF12(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageVF12_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageVF12_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF12___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF12___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF12___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF12___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF12___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF12___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF12___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF12___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF12___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageVF12_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageVF12_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageVF12_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageVF12_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageVF12_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageVF12_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageVF12_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageVF12_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageVF12_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageVF12_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageVF12_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageVF12_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageVF12_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageVF12
        __init__(self, other) -> vectoritkImageVF12

        Parameters
        ----------
        other: std::vector< itkImageVF12_Pointer > const &

        __init__(self, size) -> vectoritkImageVF12

        Parameters
        ----------
        size: std::vector< itkImageVF12_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageVF12

        Parameters
        ----------
        size: std::vector< itkImageVF12_Pointer >::size_type
        value: std::vector< itkImageVF12_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageVF12_swiginit(self, _itkImagePython.new_vectoritkImageVF12(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageVF12_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageVF12_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageVF12_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageVF12_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageVF12_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageVF12_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageVF12_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageVF12_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageVF12

# Register vectoritkImageVF12 in _itkImagePython:
_itkImagePython.vectoritkImageVF12_swigregister(vectoritkImageVF12)

class vectoritkImageVF13(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageVF13_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageVF13_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF13___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF13___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF13___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF13___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF13___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF13___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF13___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF13___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF13___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageVF13_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageVF13_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageVF13_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageVF13_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageVF13_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageVF13_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageVF13_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageVF13_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageVF13_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageVF13_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageVF13_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageVF13_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageVF13_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageVF13
        __init__(self, other) -> vectoritkImageVF13

        Parameters
        ----------
        other: std::vector< itkImageVF13_Pointer > const &

        __init__(self, size) -> vectoritkImageVF13

        Parameters
        ----------
        size: std::vector< itkImageVF13_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageVF13

        Parameters
        ----------
        size: std::vector< itkImageVF13_Pointer >::size_type
        value: std::vector< itkImageVF13_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageVF13_swiginit(self, _itkImagePython.new_vectoritkImageVF13(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageVF13_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageVF13_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageVF13_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageVF13_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageVF13_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageVF13_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageVF13_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageVF13_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageVF13

# Register vectoritkImageVF13 in _itkImagePython:
_itkImagePython.vectoritkImageVF13_swigregister(vectoritkImageVF13)

class vectoritkImageVD25(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageVD25_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageVD25_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD25___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD25___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD25___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD25___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD25___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD25___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD25___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD25___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD25___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageVD25_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageVD25_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageVD25_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageVD25_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageVD25_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageVD25_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageVD25_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageVD25_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageVD25_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageVD25_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageVD25_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageVD25_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageVD25_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageVD25
        __init__(self, other) -> vectoritkImageVD25

        Parameters
        ----------
        other: std::vector< itkImageVD25_Pointer > const &

        __init__(self, size) -> vectoritkImageVD25

        Parameters
        ----------
        size: std::vector< itkImageVD25_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageVD25

        Parameters
        ----------
        size: std::vector< itkImageVD25_Pointer >::size_type
        value: std::vector< itkImageVD25_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageVD25_swiginit(self, _itkImagePython.new_vectoritkImageVD25(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageVD25_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageVD25_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageVD25_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageVD25_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageVD25_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageVD25_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageVD25_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageVD25_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageVD25

# Register vectoritkImageVD25 in _itkImagePython:
_itkImagePython.vectoritkImageVD25_swigregister(vectoritkImageVD25)

class vectoritkImageVD35(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageVD35_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageVD35_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD35___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD35___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD35___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD35___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD35___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD35___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD35___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD35___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD35___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageVD35_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageVD35_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageVD35_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageVD35_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageVD35_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageVD35_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageVD35_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageVD35_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageVD35_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageVD35_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageVD35_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageVD35_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageVD35_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageVD35
        __init__(self, other) -> vectoritkImageVD35

        Parameters
        ----------
        other: std::vector< itkImageVD35_Pointer > const &

        __init__(self, size) -> vectoritkImageVD35

        Parameters
        ----------
        size: std::vector< itkImageVD35_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageVD35

        Parameters
        ----------
        size: std::vector< itkImageVD35_Pointer >::size_type
        value: std::vector< itkImageVD35_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageVD35_swiginit(self, _itkImagePython.new_vectoritkImageVD35(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageVD35_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageVD35_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageVD35_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageVD35_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageVD35_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageVD35_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageVD35_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageVD35_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageVD35

# Register vectoritkImageVD35 in _itkImagePython:
_itkImagePython.vectoritkImageVD35_swigregister(vectoritkImageVD35)

class vectoritkImageVD45(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageVD45_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageVD45_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD45___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD45___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD45___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD45___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD45___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD45___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD45___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD45___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVD45___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageVD45_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageVD45_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageVD45_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageVD45_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageVD45_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageVD45_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageVD45_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageVD45_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageVD45_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageVD45_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageVD45_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageVD45_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageVD45_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageVD45
        __init__(self, other) -> vectoritkImageVD45

        Parameters
        ----------
        other: std::vector< itkImageVD45_Pointer > const &

        __init__(self, size) -> vectoritkImageVD45

        Parameters
        ----------
        size: std::vector< itkImageVD45_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageVD45

        Parameters
        ----------
        size: std::vector< itkImageVD45_Pointer >::size_type
        value: std::vector< itkImageVD45_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageVD45_swiginit(self, _itkImagePython.new_vectoritkImageVD45(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageVD45_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageVD45_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageVD45_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageVD45_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageVD45_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageVD45_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageVD45_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageVD45_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageVD45

# Register vectoritkImageVD45 in _itkImagePython:
_itkImagePython.vectoritkImageVD45_swigregister(vectoritkImageVD45)

class vectoritkImageVF14(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageVF14_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageVF14_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF14___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF14___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF14___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF14___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF14___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF14___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF14___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF14___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageVF14___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageVF14_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageVF14_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageVF14_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageVF14_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageVF14_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageVF14_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageVF14_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageVF14_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageVF14_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageVF14_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageVF14_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageVF14_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageVF14_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageVF14
        __init__(self, other) -> vectoritkImageVF14

        Parameters
        ----------
        other: std::vector< itkImageVF14_Pointer > const &

        __init__(self, size) -> vectoritkImageVF14

        Parameters
        ----------
        size: std::vector< itkImageVF14_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageVF14

        Parameters
        ----------
        size: std::vector< itkImageVF14_Pointer >::size_type
        value: std::vector< itkImageVF14_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageVF14_swiginit(self, _itkImagePython.new_vectoritkImageVF14(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageVF14_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageVF14_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageVF14_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageVF14_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageVF14_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageVF14_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageVF14_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageVF14_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageVF14

# Register vectoritkImageVF14 in _itkImagePython:
_itkImagePython.vectoritkImageVF14_swigregister(vectoritkImageVF14)

class vectoritkImageCVD22(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageCVD22_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD22_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD22___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD22___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD22___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD22___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD22___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD22___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD22___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD22___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD22___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD22_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD22_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD22_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD22_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD22_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD22_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD22_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD22_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD22_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD22_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD22_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD22_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD22_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageCVD22
        __init__(self, other) -> vectoritkImageCVD22

        Parameters
        ----------
        other: std::vector< itkImageCVD22_Pointer > const &

        __init__(self, size) -> vectoritkImageCVD22

        Parameters
        ----------
        size: std::vector< itkImageCVD22_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageCVD22

        Parameters
        ----------
        size: std::vector< itkImageCVD22_Pointer >::size_type
        value: std::vector< itkImageCVD22_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageCVD22_swiginit(self, _itkImagePython.new_vectoritkImageCVD22(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD22_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD22_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD22_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD22_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD22_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD22_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD22_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD22_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageCVD22

# Register vectoritkImageCVD22 in _itkImagePython:
_itkImagePython.vectoritkImageCVD22_swigregister(vectoritkImageCVD22)

class vectoritkImageCVD32(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageCVD32_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD32_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD32___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD32___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD32___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD32___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD32___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD32___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD32___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD32___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD32___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD32_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD32_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD32_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD32_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD32_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD32_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD32_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD32_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD32_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD32_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD32_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD32_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD32_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageCVD32
        __init__(self, other) -> vectoritkImageCVD32

        Parameters
        ----------
        other: std::vector< itkImageCVD32_Pointer > const &

        __init__(self, size) -> vectoritkImageCVD32

        Parameters
        ----------
        size: std::vector< itkImageCVD32_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageCVD32

        Parameters
        ----------
        size: std::vector< itkImageCVD32_Pointer >::size_type
        value: std::vector< itkImageCVD32_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageCVD32_swiginit(self, _itkImagePython.new_vectoritkImageCVD32(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD32_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD32_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD32_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD32_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD32_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD32_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD32_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD32_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageCVD32

# Register vectoritkImageCVD32 in _itkImagePython:
_itkImagePython.vectoritkImageCVD32_swigregister(vectoritkImageCVD32)

class vectoritkImageCVD42(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageCVD42_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD42_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD42___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD42___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD42___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD42___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD42___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD42___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD42___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD42___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD42___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD42_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD42_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD42_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD42_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD42_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD42_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD42_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD42_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD42_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD42_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD42_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD42_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD42_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageCVD42
        __init__(self, other) -> vectoritkImageCVD42

        Parameters
        ----------
        other: std::vector< itkImageCVD42_Pointer > const &

        __init__(self, size) -> vectoritkImageCVD42

        Parameters
        ----------
        size: std::vector< itkImageCVD42_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageCVD42

        Parameters
        ----------
        size: std::vector< itkImageCVD42_Pointer >::size_type
        value: std::vector< itkImageCVD42_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageCVD42_swiginit(self, _itkImagePython.new_vectoritkImageCVD42(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD42_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD42_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD42_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD42_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD42_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD42_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD42_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD42_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageCVD42

# Register vectoritkImageCVD42 in _itkImagePython:
_itkImagePython.vectoritkImageCVD42_swigregister(vectoritkImageCVD42)

class vectoritkImageCVD23(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageCVD23_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD23_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD23___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD23___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD23___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD23___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD23___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD23___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD23___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD23___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD23___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD23_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD23_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD23_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD23_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD23_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD23_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD23_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD23_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD23_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD23_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD23_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD23_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD23_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageCVD23
        __init__(self, other) -> vectoritkImageCVD23

        Parameters
        ----------
        other: std::vector< itkImageCVD23_Pointer > const &

        __init__(self, size) -> vectoritkImageCVD23

        Parameters
        ----------
        size: std::vector< itkImageCVD23_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageCVD23

        Parameters
        ----------
        size: std::vector< itkImageCVD23_Pointer >::size_type
        value: std::vector< itkImageCVD23_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageCVD23_swiginit(self, _itkImagePython.new_vectoritkImageCVD23(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD23_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD23_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD23_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD23_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD23_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD23_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD23_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD23_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageCVD23

# Register vectoritkImageCVD23 in _itkImagePython:
_itkImagePython.vectoritkImageCVD23_swigregister(vectoritkImageCVD23)

class vectoritkImageCVD33(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageCVD33_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD33_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD33___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD33___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD33___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD33___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD33___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD33___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD33___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD33___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD33___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD33_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD33_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD33_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD33_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD33_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD33_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD33_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD33_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD33_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD33_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD33_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD33_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD33_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageCVD33
        __init__(self, other) -> vectoritkImageCVD33

        Parameters
        ----------
        other: std::vector< itkImageCVD33_Pointer > const &

        __init__(self, size) -> vectoritkImageCVD33

        Parameters
        ----------
        size: std::vector< itkImageCVD33_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageCVD33

        Parameters
        ----------
        size: std::vector< itkImageCVD33_Pointer >::size_type
        value: std::vector< itkImageCVD33_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageCVD33_swiginit(self, _itkImagePython.new_vectoritkImageCVD33(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD33_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD33_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD33_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD33_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD33_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD33_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD33_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD33_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageCVD33

# Register vectoritkImageCVD33 in _itkImagePython:
_itkImagePython.vectoritkImageCVD33_swigregister(vectoritkImageCVD33)

class vectoritkImageCVD43(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageCVD43_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD43_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD43___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD43___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD43___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD43___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD43___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD43___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD43___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD43___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD43___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD43_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD43_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD43_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD43_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD43_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD43_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD43_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD43_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD43_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD43_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD43_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD43_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD43_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageCVD43
        __init__(self, other) -> vectoritkImageCVD43

        Parameters
        ----------
        other: std::vector< itkImageCVD43_Pointer > const &

        __init__(self, size) -> vectoritkImageCVD43

        Parameters
        ----------
        size: std::vector< itkImageCVD43_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageCVD43

        Parameters
        ----------
        size: std::vector< itkImageCVD43_Pointer >::size_type
        value: std::vector< itkImageCVD43_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageCVD43_swiginit(self, _itkImagePython.new_vectoritkImageCVD43(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD43_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD43_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD43_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD43_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD43_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD43_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD43_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD43_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageCVD43

# Register vectoritkImageCVD43 in _itkImagePython:
_itkImagePython.vectoritkImageCVD43_swigregister(vectoritkImageCVD43)

class vectoritkImageCVD24(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageCVD24_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD24_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD24___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD24___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD24___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD24___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD24___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD24___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD24___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD24___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD24___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD24_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD24_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD24_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD24_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD24_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD24_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD24_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD24_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD24_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD24_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD24_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD24_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD24_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageCVD24
        __init__(self, other) -> vectoritkImageCVD24

        Parameters
        ----------
        other: std::vector< itkImageCVD24_Pointer > const &

        __init__(self, size) -> vectoritkImageCVD24

        Parameters
        ----------
        size: std::vector< itkImageCVD24_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageCVD24

        Parameters
        ----------
        size: std::vector< itkImageCVD24_Pointer >::size_type
        value: std::vector< itkImageCVD24_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageCVD24_swiginit(self, _itkImagePython.new_vectoritkImageCVD24(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD24_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD24_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD24_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD24_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD24_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD24_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD24_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD24_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageCVD24

# Register vectoritkImageCVD24 in _itkImagePython:
_itkImagePython.vectoritkImageCVD24_swigregister(vectoritkImageCVD24)

class vectoritkImageCVD34(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageCVD34_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD34_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD34___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD34___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD34___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD34___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD34___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD34___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD34___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD34___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD34___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD34_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD34_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD34_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD34_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD34_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD34_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD34_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD34_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD34_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD34_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD34_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD34_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD34_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageCVD34
        __init__(self, other) -> vectoritkImageCVD34

        Parameters
        ----------
        other: std::vector< itkImageCVD34_Pointer > const &

        __init__(self, size) -> vectoritkImageCVD34

        Parameters
        ----------
        size: std::vector< itkImageCVD34_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageCVD34

        Parameters
        ----------
        size: std::vector< itkImageCVD34_Pointer >::size_type
        value: std::vector< itkImageCVD34_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageCVD34_swiginit(self, _itkImagePython.new_vectoritkImageCVD34(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD34_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD34_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD34_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD34_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD34_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD34_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD34_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD34_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageCVD34

# Register vectoritkImageCVD34 in _itkImagePython:
_itkImagePython.vectoritkImageCVD34_swigregister(vectoritkImageCVD34)

class vectoritkImageCVD44(collections.abc.MutableSequence):
    r"""Proxy of C++ std::vector< itkImageCVD44_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD44_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD44___nonzero__)
    __bool__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD44___bool__)
    __len__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD44___len__)
    __getslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD44___getslice__)
    __setslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD44___setslice__)
    __delslice__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD44___delslice__)
    __delitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD44___delitem__)
    __getitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD44___getitem__)
    __setitem__ = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD44___setitem__)
    pop = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD44_pop)
    append = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD44_append)
    empty = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD44_empty)
    size = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD44_size)
    swap = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD44_swap)
    begin = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD44_begin)
    end = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD44_end)
    rbegin = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD44_rbegin)
    rend = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD44_rend)
    clear = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD44_clear)
    get_allocator = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD44_get_allocator)
    pop_back = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD44_pop_back)
    erase = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD44_erase)

    def __init__(self, *args):
        r"""
        __init__(self) -> vectoritkImageCVD44
        __init__(self, other) -> vectoritkImageCVD44

        Parameters
        ----------
        other: std::vector< itkImageCVD44_Pointer > const &

        __init__(self, size) -> vectoritkImageCVD44

        Parameters
        ----------
        size: std::vector< itkImageCVD44_Pointer >::size_type

        __init__(self, size, value) -> vectoritkImageCVD44

        Parameters
        ----------
        size: std::vector< itkImageCVD44_Pointer >::size_type
        value: std::vector< itkImageCVD44_Pointer >::value_type const &

        """
        _itkImagePython.vectoritkImageCVD44_swiginit(self, _itkImagePython.new_vectoritkImageCVD44(*args))
    push_back = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD44_push_back)
    front = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD44_front)
    back = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD44_back)
    assign = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD44_assign)
    resize = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD44_resize)
    insert = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD44_insert)
    reserve = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD44_reserve)
    capacity = _swig_new_instance_method(_itkImagePython.vectoritkImageCVD44_capacity)
    __swig_destroy__ = _itkImagePython.delete_vectoritkImageCVD44

# Register vectoritkImageCVD44 in _itkImagePython:
_itkImagePython.vectoritkImageCVD44_swigregister(vectoritkImageCVD44)


def itkImageBase2_New():
    return itkImageBase2.New()

class itkImageBase2(itk.ITKCommonBasePython.itkDataObject):
    r"""


    Base class for templated image classes.

    ImageBase is the base class for the templated Image classes. ImageBase
    is templated over the dimension of the image. It provides the API and
    ivars that depend solely on the dimension of the image. ImageBase does
    not store any of the image (pixel) data. Storage for the pixels and
    the pixel access methods are defined in subclasses of ImageBase,
    namely Image and ImageAdaptor.

    ImageBase manages the geometry of an image. The geometry of an image
    is defined by its position, orientation, spacing, and extent.

    The position and orientation of an image is defined by its "Origin"
    and its "Directions". The "Origin" is the physical position of the
    pixel whose "Index" is all zeros. The "Direction" of an image is a
    matrix whose columns indicate the direction in physical space that
    each dimension of the image traverses. The first column defines the
    direction that the fastest moving index in the image traverses in
    physical space while the last column defines the direction that the
    slowest moving index in the image traverses in physical space.

    The extent of an image is defined by the pixel spacing and a set of
    regions. The "Spacing" is the size of a pixel in physical space
    along each dimension. Regions describe a portion of an image grid via
    a starting index for the image array and a size (or number of pixels)
    in each dimension. The ivar LargestPossibleRegion defines the size and
    starting index of the image dataset. The entire image dataset,
    however, may not be resident in memory. The region of the image that
    is resident in memory is defined by the "BufferedRegion". The Buffer
    is a contiguous block of memory. The third set of meta-data defines a
    region of interest, called the "RequestedRegion". The
    RequestedRegion is used by the pipeline execution model to define what
    a filter is requested to produce.

    [RegionIndex, RegionSize] C [BufferIndex, BufferSize] C [ImageIndex,
    ImageSize]

    ImageBase provides all the methods for converting between the physical
    space and index coordinate frames. TransformIndexToPhysicalPoint()
    converts an Index in the pixel array into its coordinates in physical
    space. TransformPhysicalPointToIndex() converts a position in physical
    space into an Index into the pixel array (using rounding). Subpixel
    locations are supported by methods that convert to and from
    ContinuousIndex types.

    ImageBase also provides helper routines for the ImageIterators which
    convert an Index to an offset in memory from the first pixel address
    as well as covert an offset in memory from the first pixel address to
    an Index. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageBase2___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageBase2_Clone)
    GetImageDimension = _swig_new_static_method(_itkImagePython.itkImageBase2_GetImageDimension)
    SetOrigin = _swig_new_instance_method(_itkImagePython.itkImageBase2_SetOrigin)
    __SetDirection_orig__ = _swig_new_instance_method(_itkImagePython.itkImageBase2___SetDirection_orig__)
    GetDirection = _swig_new_instance_method(_itkImagePython.itkImageBase2_GetDirection)
    GetInverseDirection = _swig_new_instance_method(_itkImagePython.itkImageBase2_GetInverseDirection)
    GetSpacing = _swig_new_instance_method(_itkImagePython.itkImageBase2_GetSpacing)
    GetOrigin = _swig_new_instance_method(_itkImagePython.itkImageBase2_GetOrigin)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageBase2_Allocate)
    SetLargestPossibleRegion = _swig_new_instance_method(_itkImagePython.itkImageBase2_SetLargestPossibleRegion)
    __GetLargestPossibleRegion_orig__ = _swig_new_instance_method(_itkImagePython.itkImageBase2___GetLargestPossibleRegion_orig__)
    SetBufferedRegion = _swig_new_instance_method(_itkImagePython.itkImageBase2_SetBufferedRegion)
    __GetBufferedRegion_orig__ = _swig_new_instance_method(_itkImagePython.itkImageBase2___GetBufferedRegion_orig__)
    SetRequestedRegion = _swig_new_instance_method(_itkImagePython.itkImageBase2_SetRequestedRegion)
    __GetRequestedRegion_orig__ = _swig_new_instance_method(_itkImagePython.itkImageBase2___GetRequestedRegion_orig__)
    SetRegions = _swig_new_instance_method(_itkImagePython.itkImageBase2_SetRegions)
    GetOffsetTable = _swig_new_instance_method(_itkImagePython.itkImageBase2_GetOffsetTable)
    ComputeOffset = _swig_new_instance_method(_itkImagePython.itkImageBase2_ComputeOffset)
    ComputeIndex = _swig_new_instance_method(_itkImagePython.itkImageBase2_ComputeIndex)
    SetSpacing = _swig_new_instance_method(_itkImagePython.itkImageBase2_SetSpacing)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageBase2_Graft)
    GetNumberOfComponentsPerPixel = _swig_new_instance_method(_itkImagePython.itkImageBase2_GetNumberOfComponentsPerPixel)
    SetNumberOfComponentsPerPixel = _swig_new_instance_method(_itkImagePython.itkImageBase2_SetNumberOfComponentsPerPixel)
    __swig_destroy__ = _itkImagePython.delete_itkImageBase2
    cast = _swig_new_static_method(_itkImagePython.itkImageBase2_cast)

    def GetBufferedRegion(self):
        var = self.__GetBufferedRegion_orig__()
        var_copy = type(var)(var)
        return var_copy


    def GetLargestPossibleRegion(self):
        var = self.__GetLargestPossibleRegion_orig__()
        var_copy = type(var)(var)
        return var_copy


    def GetRequestedRegion(self):
        var = self.__GetRequestedRegion_orig__()
        var_copy = type(var)(var)
        return var_copy

    TransformPhysicalPointToIndex = _swig_new_instance_method(_itkImagePython.itkImageBase2_TransformPhysicalPointToIndex)
    TransformPhysicalPointToContinuousIndex = _swig_new_instance_method(_itkImagePython.itkImageBase2_TransformPhysicalPointToContinuousIndex)
    TransformContinuousIndexToPhysicalPoint = _swig_new_instance_method(_itkImagePython.itkImageBase2_TransformContinuousIndexToPhysicalPoint)
    TransformIndexToPhysicalPoint = _swig_new_instance_method(_itkImagePython.itkImageBase2_TransformIndexToPhysicalPoint)

    def _SetBase(self, base):
        """Internal method to keep a reference when creating a view of a NumPy array."""
        self.base = base

    @property
    def ndim(self):
        """Equivalant to the np.ndarray ndim attribute when converted
        to an image with itk.array_view_from_image."""
        spatial_dims = self.GetImageDimension()
        if self.GetNumberOfComponentsPerPixel() > 1:
            return spatial_dims + 1
        else:
            return spatial_dims

    @property
    def shape(self):
        """Equivalant to the np.ndarray shape attribute when converted
        to an image with itk.array_view_from_image."""
        itksize = self.GetLargestPossibleRegion().GetSize()
        dim = len(itksize)
        result = [int(itksize[idx]) for idx in range(dim)]

        if(self.GetNumberOfComponentsPerPixel() > 1):
            result = [self.GetNumberOfComponentsPerPixel(), ] + result
        result.reverse()
        return tuple(result)

    @property
    def dtype(self):
        """Equivalant to the np.ndarray dtype attribute when converted
        to an image with itk.array_view_from_image."""
        import itk
        first_template_arg = itk.template(self)[1][0]
        if hasattr(first_template_arg, 'dtype'):
            return first_template_arg.dtype
        else:
#Multi-component pixel types, e.g. Vector,
#CovariantVector, etc.
            return itk.template(first_template_arg)[1][0].dtype

    def astype(self, pixel_type):
        """Cast the image to the provided itk pixel type or equivalent NumPy dtype."""
        import itk
        import numpy as np
        from itk.support import types

#if both a numpy dtype and a ctype exist, use the latter.
        if type(pixel_type) is type:
            c_pixel_type = types.itkCType.GetCTypeForDType(pixel_type)
            if c_pixel_type is not None:
                pixel_type = c_pixel_type

#input_image_template is Image or VectorImage
        (input_image_template, (input_pixel_type, input_image_dimension)) = itk.template(self)

        if input_pixel_type is pixel_type:
            return self
        OutputImageType = input_image_template[pixel_type, input_image_dimension]
        cast = itk.cast_image_filter(self, ttype=(type(self), OutputImageType))
        return cast

    def SetDirection(self, direction):
        from itk.support import helpers
        if helpers.is_arraylike(direction):
            import itk
            import numpy as np

            array = np.asarray(direction).astype(np.float64)
            dimension = self.GetImageDimension()
            for dim in array.shape:
                if dim != dimension:
                    raise ValueError('Array does not have the expected shape')
            matrix = itk.matrix_from_array(array)
            self.__SetDirection_orig__(matrix)
        else:
            self.__SetDirection_orig__(direction)

    def keys(self):
        """Return keys related to the image's metadata.

        These keys are used in the dictionary resulting from dict(image).

        These keys include MetaDataDictionary keys along with
        'origin', 'spacing', and 'direction' keys, which
        correspond to the image's Origin, Spacing, and Direction. However,
        they are in (z, y, x) order as opposed to (x, y, z) order to
        correspond to the indexing of the shape of the pixel buffer
        array resulting from np.array(image).
        """
        meta_keys = self.GetMetaDataDictionary().GetKeys()
#Ignore deprecated, legacy members that cause issues
        result = list(filter(lambda k: not k.startswith('ITK_original'), meta_keys))
        result.extend(['origin', 'spacing', 'direction'])
        return result

    def __getitem__(self, key):
        """Access metadata keys, see help(image.keys), for string
        keys, otherwise provide NumPy indexing to the pixel buffer
        array view. The index order follows NumPy array indexing
        order, i.e. [z, y, x] versus [x, y, z]."""
        import itk
        if isinstance(key, str):
            import numpy as np
            if key == 'origin':
                return np.flip(np.asarray(self.GetOrigin()), axis=None)
            elif key == 'spacing':
                return np.flip(np.asarray(self.GetSpacing()), axis=None)
            elif key == 'direction':
                return np.flip(itk.array_from_matrix(self.GetDirection()), axis=None)
            else:
                return self.GetMetaDataDictionary()[key]
        else:
            return itk.array_view_from_image(self).__getitem__(key)

    def __setitem__(self, key, value):
        """Set metadata keys, see help(image.keys), for string
        keys, otherwise provide NumPy indexing to the pixel buffer
        array view. The index order follows NumPy array indexing
        order, i.e. [z, y, x] versus [x, y, z]."""
        if isinstance(key, str):
            import numpy as np
            if key == 'origin':
                self.SetOrigin(np.flip(value, axis=None))
            elif key == 'spacing':
                self.SetSpacing(np.flip(value, axis=None))
            elif key == 'direction':
                self.SetDirection(np.flip(value, axis=None))
            else:
                self.GetMetaDataDictionary()[key] = value
        else:
            import itk
            itk.array_view_from_image(self).__setitem__(key, value)



    def New(*args, **kargs):
        """New() -> itkImageBase2

        Create a new object of the class itkImageBase2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageBase2.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageBase2.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageBase2.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageBase2 in _itkImagePython:
_itkImagePython.itkImageBase2_swigregister(itkImageBase2)
itkImageBase2___New_orig__ = _itkImagePython.itkImageBase2___New_orig__
itkImageBase2_GetImageDimension = _itkImagePython.itkImageBase2_GetImageDimension
itkImageBase2_cast = _itkImagePython.itkImageBase2_cast


def itkImageBase3_New():
    return itkImageBase3.New()

class itkImageBase3(itk.ITKCommonBasePython.itkDataObject):
    r"""


    Base class for templated image classes.

    ImageBase is the base class for the templated Image classes. ImageBase
    is templated over the dimension of the image. It provides the API and
    ivars that depend solely on the dimension of the image. ImageBase does
    not store any of the image (pixel) data. Storage for the pixels and
    the pixel access methods are defined in subclasses of ImageBase,
    namely Image and ImageAdaptor.

    ImageBase manages the geometry of an image. The geometry of an image
    is defined by its position, orientation, spacing, and extent.

    The position and orientation of an image is defined by its "Origin"
    and its "Directions". The "Origin" is the physical position of the
    pixel whose "Index" is all zeros. The "Direction" of an image is a
    matrix whose columns indicate the direction in physical space that
    each dimension of the image traverses. The first column defines the
    direction that the fastest moving index in the image traverses in
    physical space while the last column defines the direction that the
    slowest moving index in the image traverses in physical space.

    The extent of an image is defined by the pixel spacing and a set of
    regions. The "Spacing" is the size of a pixel in physical space
    along each dimension. Regions describe a portion of an image grid via
    a starting index for the image array and a size (or number of pixels)
    in each dimension. The ivar LargestPossibleRegion defines the size and
    starting index of the image dataset. The entire image dataset,
    however, may not be resident in memory. The region of the image that
    is resident in memory is defined by the "BufferedRegion". The Buffer
    is a contiguous block of memory. The third set of meta-data defines a
    region of interest, called the "RequestedRegion". The
    RequestedRegion is used by the pipeline execution model to define what
    a filter is requested to produce.

    [RegionIndex, RegionSize] C [BufferIndex, BufferSize] C [ImageIndex,
    ImageSize]

    ImageBase provides all the methods for converting between the physical
    space and index coordinate frames. TransformIndexToPhysicalPoint()
    converts an Index in the pixel array into its coordinates in physical
    space. TransformPhysicalPointToIndex() converts a position in physical
    space into an Index into the pixel array (using rounding). Subpixel
    locations are supported by methods that convert to and from
    ContinuousIndex types.

    ImageBase also provides helper routines for the ImageIterators which
    convert an Index to an offset in memory from the first pixel address
    as well as covert an offset in memory from the first pixel address to
    an Index. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageBase3___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageBase3_Clone)
    GetImageDimension = _swig_new_static_method(_itkImagePython.itkImageBase3_GetImageDimension)
    SetOrigin = _swig_new_instance_method(_itkImagePython.itkImageBase3_SetOrigin)
    __SetDirection_orig__ = _swig_new_instance_method(_itkImagePython.itkImageBase3___SetDirection_orig__)
    GetDirection = _swig_new_instance_method(_itkImagePython.itkImageBase3_GetDirection)
    GetInverseDirection = _swig_new_instance_method(_itkImagePython.itkImageBase3_GetInverseDirection)
    GetSpacing = _swig_new_instance_method(_itkImagePython.itkImageBase3_GetSpacing)
    GetOrigin = _swig_new_instance_method(_itkImagePython.itkImageBase3_GetOrigin)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageBase3_Allocate)
    SetLargestPossibleRegion = _swig_new_instance_method(_itkImagePython.itkImageBase3_SetLargestPossibleRegion)
    __GetLargestPossibleRegion_orig__ = _swig_new_instance_method(_itkImagePython.itkImageBase3___GetLargestPossibleRegion_orig__)
    SetBufferedRegion = _swig_new_instance_method(_itkImagePython.itkImageBase3_SetBufferedRegion)
    __GetBufferedRegion_orig__ = _swig_new_instance_method(_itkImagePython.itkImageBase3___GetBufferedRegion_orig__)
    SetRequestedRegion = _swig_new_instance_method(_itkImagePython.itkImageBase3_SetRequestedRegion)
    __GetRequestedRegion_orig__ = _swig_new_instance_method(_itkImagePython.itkImageBase3___GetRequestedRegion_orig__)
    SetRegions = _swig_new_instance_method(_itkImagePython.itkImageBase3_SetRegions)
    GetOffsetTable = _swig_new_instance_method(_itkImagePython.itkImageBase3_GetOffsetTable)
    ComputeOffset = _swig_new_instance_method(_itkImagePython.itkImageBase3_ComputeOffset)
    ComputeIndex = _swig_new_instance_method(_itkImagePython.itkImageBase3_ComputeIndex)
    SetSpacing = _swig_new_instance_method(_itkImagePython.itkImageBase3_SetSpacing)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageBase3_Graft)
    GetNumberOfComponentsPerPixel = _swig_new_instance_method(_itkImagePython.itkImageBase3_GetNumberOfComponentsPerPixel)
    SetNumberOfComponentsPerPixel = _swig_new_instance_method(_itkImagePython.itkImageBase3_SetNumberOfComponentsPerPixel)
    __swig_destroy__ = _itkImagePython.delete_itkImageBase3
    cast = _swig_new_static_method(_itkImagePython.itkImageBase3_cast)

    def GetBufferedRegion(self):
        var = self.__GetBufferedRegion_orig__()
        var_copy = type(var)(var)
        return var_copy


    def GetLargestPossibleRegion(self):
        var = self.__GetLargestPossibleRegion_orig__()
        var_copy = type(var)(var)
        return var_copy


    def GetRequestedRegion(self):
        var = self.__GetRequestedRegion_orig__()
        var_copy = type(var)(var)
        return var_copy

    TransformPhysicalPointToIndex = _swig_new_instance_method(_itkImagePython.itkImageBase3_TransformPhysicalPointToIndex)
    TransformPhysicalPointToContinuousIndex = _swig_new_instance_method(_itkImagePython.itkImageBase3_TransformPhysicalPointToContinuousIndex)
    TransformContinuousIndexToPhysicalPoint = _swig_new_instance_method(_itkImagePython.itkImageBase3_TransformContinuousIndexToPhysicalPoint)
    TransformIndexToPhysicalPoint = _swig_new_instance_method(_itkImagePython.itkImageBase3_TransformIndexToPhysicalPoint)

    def _SetBase(self, base):
        """Internal method to keep a reference when creating a view of a NumPy array."""
        self.base = base

    @property
    def ndim(self):
        """Equivalant to the np.ndarray ndim attribute when converted
        to an image with itk.array_view_from_image."""
        spatial_dims = self.GetImageDimension()
        if self.GetNumberOfComponentsPerPixel() > 1:
            return spatial_dims + 1
        else:
            return spatial_dims

    @property
    def shape(self):
        """Equivalant to the np.ndarray shape attribute when converted
        to an image with itk.array_view_from_image."""
        itksize = self.GetLargestPossibleRegion().GetSize()
        dim = len(itksize)
        result = [int(itksize[idx]) for idx in range(dim)]

        if(self.GetNumberOfComponentsPerPixel() > 1):
            result = [self.GetNumberOfComponentsPerPixel(), ] + result
        result.reverse()
        return tuple(result)

    @property
    def dtype(self):
        """Equivalant to the np.ndarray dtype attribute when converted
        to an image with itk.array_view_from_image."""
        import itk
        first_template_arg = itk.template(self)[1][0]
        if hasattr(first_template_arg, 'dtype'):
            return first_template_arg.dtype
        else:
#Multi-component pixel types, e.g. Vector,
#CovariantVector, etc.
            return itk.template(first_template_arg)[1][0].dtype

    def astype(self, pixel_type):
        """Cast the image to the provided itk pixel type or equivalent NumPy dtype."""
        import itk
        import numpy as np
        from itk.support import types

#if both a numpy dtype and a ctype exist, use the latter.
        if type(pixel_type) is type:
            c_pixel_type = types.itkCType.GetCTypeForDType(pixel_type)
            if c_pixel_type is not None:
                pixel_type = c_pixel_type

#input_image_template is Image or VectorImage
        (input_image_template, (input_pixel_type, input_image_dimension)) = itk.template(self)

        if input_pixel_type is pixel_type:
            return self
        OutputImageType = input_image_template[pixel_type, input_image_dimension]
        cast = itk.cast_image_filter(self, ttype=(type(self), OutputImageType))
        return cast

    def SetDirection(self, direction):
        from itk.support import helpers
        if helpers.is_arraylike(direction):
            import itk
            import numpy as np

            array = np.asarray(direction).astype(np.float64)
            dimension = self.GetImageDimension()
            for dim in array.shape:
                if dim != dimension:
                    raise ValueError('Array does not have the expected shape')
            matrix = itk.matrix_from_array(array)
            self.__SetDirection_orig__(matrix)
        else:
            self.__SetDirection_orig__(direction)

    def keys(self):
        """Return keys related to the image's metadata.

        These keys are used in the dictionary resulting from dict(image).

        These keys include MetaDataDictionary keys along with
        'origin', 'spacing', and 'direction' keys, which
        correspond to the image's Origin, Spacing, and Direction. However,
        they are in (z, y, x) order as opposed to (x, y, z) order to
        correspond to the indexing of the shape of the pixel buffer
        array resulting from np.array(image).
        """
        meta_keys = self.GetMetaDataDictionary().GetKeys()
#Ignore deprecated, legacy members that cause issues
        result = list(filter(lambda k: not k.startswith('ITK_original'), meta_keys))
        result.extend(['origin', 'spacing', 'direction'])
        return result

    def __getitem__(self, key):
        """Access metadata keys, see help(image.keys), for string
        keys, otherwise provide NumPy indexing to the pixel buffer
        array view. The index order follows NumPy array indexing
        order, i.e. [z, y, x] versus [x, y, z]."""
        import itk
        if isinstance(key, str):
            import numpy as np
            if key == 'origin':
                return np.flip(np.asarray(self.GetOrigin()), axis=None)
            elif key == 'spacing':
                return np.flip(np.asarray(self.GetSpacing()), axis=None)
            elif key == 'direction':
                return np.flip(itk.array_from_matrix(self.GetDirection()), axis=None)
            else:
                return self.GetMetaDataDictionary()[key]
        else:
            return itk.array_view_from_image(self).__getitem__(key)

    def __setitem__(self, key, value):
        """Set metadata keys, see help(image.keys), for string
        keys, otherwise provide NumPy indexing to the pixel buffer
        array view. The index order follows NumPy array indexing
        order, i.e. [z, y, x] versus [x, y, z]."""
        if isinstance(key, str):
            import numpy as np
            if key == 'origin':
                self.SetOrigin(np.flip(value, axis=None))
            elif key == 'spacing':
                self.SetSpacing(np.flip(value, axis=None))
            elif key == 'direction':
                self.SetDirection(np.flip(value, axis=None))
            else:
                self.GetMetaDataDictionary()[key] = value
        else:
            import itk
            itk.array_view_from_image(self).__setitem__(key, value)



    def New(*args, **kargs):
        """New() -> itkImageBase3

        Create a new object of the class itkImageBase3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageBase3.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageBase3.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageBase3.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageBase3 in _itkImagePython:
_itkImagePython.itkImageBase3_swigregister(itkImageBase3)
itkImageBase3___New_orig__ = _itkImagePython.itkImageBase3___New_orig__
itkImageBase3_GetImageDimension = _itkImagePython.itkImageBase3_GetImageDimension
itkImageBase3_cast = _itkImagePython.itkImageBase3_cast


def itkImageBase4_New():
    return itkImageBase4.New()

class itkImageBase4(itk.ITKCommonBasePython.itkDataObject):
    r"""


    Base class for templated image classes.

    ImageBase is the base class for the templated Image classes. ImageBase
    is templated over the dimension of the image. It provides the API and
    ivars that depend solely on the dimension of the image. ImageBase does
    not store any of the image (pixel) data. Storage for the pixels and
    the pixel access methods are defined in subclasses of ImageBase,
    namely Image and ImageAdaptor.

    ImageBase manages the geometry of an image. The geometry of an image
    is defined by its position, orientation, spacing, and extent.

    The position and orientation of an image is defined by its "Origin"
    and its "Directions". The "Origin" is the physical position of the
    pixel whose "Index" is all zeros. The "Direction" of an image is a
    matrix whose columns indicate the direction in physical space that
    each dimension of the image traverses. The first column defines the
    direction that the fastest moving index in the image traverses in
    physical space while the last column defines the direction that the
    slowest moving index in the image traverses in physical space.

    The extent of an image is defined by the pixel spacing and a set of
    regions. The "Spacing" is the size of a pixel in physical space
    along each dimension. Regions describe a portion of an image grid via
    a starting index for the image array and a size (or number of pixels)
    in each dimension. The ivar LargestPossibleRegion defines the size and
    starting index of the image dataset. The entire image dataset,
    however, may not be resident in memory. The region of the image that
    is resident in memory is defined by the "BufferedRegion". The Buffer
    is a contiguous block of memory. The third set of meta-data defines a
    region of interest, called the "RequestedRegion". The
    RequestedRegion is used by the pipeline execution model to define what
    a filter is requested to produce.

    [RegionIndex, RegionSize] C [BufferIndex, BufferSize] C [ImageIndex,
    ImageSize]

    ImageBase provides all the methods for converting between the physical
    space and index coordinate frames. TransformIndexToPhysicalPoint()
    converts an Index in the pixel array into its coordinates in physical
    space. TransformPhysicalPointToIndex() converts a position in physical
    space into an Index into the pixel array (using rounding). Subpixel
    locations are supported by methods that convert to and from
    ContinuousIndex types.

    ImageBase also provides helper routines for the ImageIterators which
    convert an Index to an offset in memory from the first pixel address
    as well as covert an offset in memory from the first pixel address to
    an Index. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageBase4___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageBase4_Clone)
    GetImageDimension = _swig_new_static_method(_itkImagePython.itkImageBase4_GetImageDimension)
    SetOrigin = _swig_new_instance_method(_itkImagePython.itkImageBase4_SetOrigin)
    __SetDirection_orig__ = _swig_new_instance_method(_itkImagePython.itkImageBase4___SetDirection_orig__)
    GetDirection = _swig_new_instance_method(_itkImagePython.itkImageBase4_GetDirection)
    GetInverseDirection = _swig_new_instance_method(_itkImagePython.itkImageBase4_GetInverseDirection)
    GetSpacing = _swig_new_instance_method(_itkImagePython.itkImageBase4_GetSpacing)
    GetOrigin = _swig_new_instance_method(_itkImagePython.itkImageBase4_GetOrigin)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageBase4_Allocate)
    SetLargestPossibleRegion = _swig_new_instance_method(_itkImagePython.itkImageBase4_SetLargestPossibleRegion)
    __GetLargestPossibleRegion_orig__ = _swig_new_instance_method(_itkImagePython.itkImageBase4___GetLargestPossibleRegion_orig__)
    SetBufferedRegion = _swig_new_instance_method(_itkImagePython.itkImageBase4_SetBufferedRegion)
    __GetBufferedRegion_orig__ = _swig_new_instance_method(_itkImagePython.itkImageBase4___GetBufferedRegion_orig__)
    SetRequestedRegion = _swig_new_instance_method(_itkImagePython.itkImageBase4_SetRequestedRegion)
    __GetRequestedRegion_orig__ = _swig_new_instance_method(_itkImagePython.itkImageBase4___GetRequestedRegion_orig__)
    SetRegions = _swig_new_instance_method(_itkImagePython.itkImageBase4_SetRegions)
    GetOffsetTable = _swig_new_instance_method(_itkImagePython.itkImageBase4_GetOffsetTable)
    ComputeOffset = _swig_new_instance_method(_itkImagePython.itkImageBase4_ComputeOffset)
    ComputeIndex = _swig_new_instance_method(_itkImagePython.itkImageBase4_ComputeIndex)
    SetSpacing = _swig_new_instance_method(_itkImagePython.itkImageBase4_SetSpacing)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageBase4_Graft)
    GetNumberOfComponentsPerPixel = _swig_new_instance_method(_itkImagePython.itkImageBase4_GetNumberOfComponentsPerPixel)
    SetNumberOfComponentsPerPixel = _swig_new_instance_method(_itkImagePython.itkImageBase4_SetNumberOfComponentsPerPixel)
    __swig_destroy__ = _itkImagePython.delete_itkImageBase4
    cast = _swig_new_static_method(_itkImagePython.itkImageBase4_cast)

    def GetBufferedRegion(self):
        var = self.__GetBufferedRegion_orig__()
        var_copy = type(var)(var)
        return var_copy


    def GetLargestPossibleRegion(self):
        var = self.__GetLargestPossibleRegion_orig__()
        var_copy = type(var)(var)
        return var_copy


    def GetRequestedRegion(self):
        var = self.__GetRequestedRegion_orig__()
        var_copy = type(var)(var)
        return var_copy

    TransformPhysicalPointToIndex = _swig_new_instance_method(_itkImagePython.itkImageBase4_TransformPhysicalPointToIndex)
    TransformPhysicalPointToContinuousIndex = _swig_new_instance_method(_itkImagePython.itkImageBase4_TransformPhysicalPointToContinuousIndex)
    TransformContinuousIndexToPhysicalPoint = _swig_new_instance_method(_itkImagePython.itkImageBase4_TransformContinuousIndexToPhysicalPoint)
    TransformIndexToPhysicalPoint = _swig_new_instance_method(_itkImagePython.itkImageBase4_TransformIndexToPhysicalPoint)

    def _SetBase(self, base):
        """Internal method to keep a reference when creating a view of a NumPy array."""
        self.base = base

    @property
    def ndim(self):
        """Equivalant to the np.ndarray ndim attribute when converted
        to an image with itk.array_view_from_image."""
        spatial_dims = self.GetImageDimension()
        if self.GetNumberOfComponentsPerPixel() > 1:
            return spatial_dims + 1
        else:
            return spatial_dims

    @property
    def shape(self):
        """Equivalant to the np.ndarray shape attribute when converted
        to an image with itk.array_view_from_image."""
        itksize = self.GetLargestPossibleRegion().GetSize()
        dim = len(itksize)
        result = [int(itksize[idx]) for idx in range(dim)]

        if(self.GetNumberOfComponentsPerPixel() > 1):
            result = [self.GetNumberOfComponentsPerPixel(), ] + result
        result.reverse()
        return tuple(result)

    @property
    def dtype(self):
        """Equivalant to the np.ndarray dtype attribute when converted
        to an image with itk.array_view_from_image."""
        import itk
        first_template_arg = itk.template(self)[1][0]
        if hasattr(first_template_arg, 'dtype'):
            return first_template_arg.dtype
        else:
#Multi-component pixel types, e.g. Vector,
#CovariantVector, etc.
            return itk.template(first_template_arg)[1][0].dtype

    def astype(self, pixel_type):
        """Cast the image to the provided itk pixel type or equivalent NumPy dtype."""
        import itk
        import numpy as np
        from itk.support import types

#if both a numpy dtype and a ctype exist, use the latter.
        if type(pixel_type) is type:
            c_pixel_type = types.itkCType.GetCTypeForDType(pixel_type)
            if c_pixel_type is not None:
                pixel_type = c_pixel_type

#input_image_template is Image or VectorImage
        (input_image_template, (input_pixel_type, input_image_dimension)) = itk.template(self)

        if input_pixel_type is pixel_type:
            return self
        OutputImageType = input_image_template[pixel_type, input_image_dimension]
        cast = itk.cast_image_filter(self, ttype=(type(self), OutputImageType))
        return cast

    def SetDirection(self, direction):
        from itk.support import helpers
        if helpers.is_arraylike(direction):
            import itk
            import numpy as np

            array = np.asarray(direction).astype(np.float64)
            dimension = self.GetImageDimension()
            for dim in array.shape:
                if dim != dimension:
                    raise ValueError('Array does not have the expected shape')
            matrix = itk.matrix_from_array(array)
            self.__SetDirection_orig__(matrix)
        else:
            self.__SetDirection_orig__(direction)

    def keys(self):
        """Return keys related to the image's metadata.

        These keys are used in the dictionary resulting from dict(image).

        These keys include MetaDataDictionary keys along with
        'origin', 'spacing', and 'direction' keys, which
        correspond to the image's Origin, Spacing, and Direction. However,
        they are in (z, y, x) order as opposed to (x, y, z) order to
        correspond to the indexing of the shape of the pixel buffer
        array resulting from np.array(image).
        """
        meta_keys = self.GetMetaDataDictionary().GetKeys()
#Ignore deprecated, legacy members that cause issues
        result = list(filter(lambda k: not k.startswith('ITK_original'), meta_keys))
        result.extend(['origin', 'spacing', 'direction'])
        return result

    def __getitem__(self, key):
        """Access metadata keys, see help(image.keys), for string
        keys, otherwise provide NumPy indexing to the pixel buffer
        array view. The index order follows NumPy array indexing
        order, i.e. [z, y, x] versus [x, y, z]."""
        import itk
        if isinstance(key, str):
            import numpy as np
            if key == 'origin':
                return np.flip(np.asarray(self.GetOrigin()), axis=None)
            elif key == 'spacing':
                return np.flip(np.asarray(self.GetSpacing()), axis=None)
            elif key == 'direction':
                return np.flip(itk.array_from_matrix(self.GetDirection()), axis=None)
            else:
                return self.GetMetaDataDictionary()[key]
        else:
            return itk.array_view_from_image(self).__getitem__(key)

    def __setitem__(self, key, value):
        """Set metadata keys, see help(image.keys), for string
        keys, otherwise provide NumPy indexing to the pixel buffer
        array view. The index order follows NumPy array indexing
        order, i.e. [z, y, x] versus [x, y, z]."""
        if isinstance(key, str):
            import numpy as np
            if key == 'origin':
                self.SetOrigin(np.flip(value, axis=None))
            elif key == 'spacing':
                self.SetSpacing(np.flip(value, axis=None))
            elif key == 'direction':
                self.SetDirection(np.flip(value, axis=None))
            else:
                self.GetMetaDataDictionary()[key] = value
        else:
            import itk
            itk.array_view_from_image(self).__setitem__(key, value)



    def New(*args, **kargs):
        """New() -> itkImageBase4

        Create a new object of the class itkImageBase4 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageBase4.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageBase4.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageBase4.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageBase4 in _itkImagePython:
_itkImagePython.itkImageBase4_swigregister(itkImageBase4)
itkImageBase4___New_orig__ = _itkImagePython.itkImageBase4___New_orig__
itkImageBase4_GetImageDimension = _itkImagePython.itkImageBase4_GetImageDimension
itkImageBase4_cast = _itkImagePython.itkImageBase4_cast


def itkImageBase5_New():
    return itkImageBase5.New()

class itkImageBase5(itk.ITKCommonBasePython.itkDataObject):
    r"""


    Base class for templated image classes.

    ImageBase is the base class for the templated Image classes. ImageBase
    is templated over the dimension of the image. It provides the API and
    ivars that depend solely on the dimension of the image. ImageBase does
    not store any of the image (pixel) data. Storage for the pixels and
    the pixel access methods are defined in subclasses of ImageBase,
    namely Image and ImageAdaptor.

    ImageBase manages the geometry of an image. The geometry of an image
    is defined by its position, orientation, spacing, and extent.

    The position and orientation of an image is defined by its "Origin"
    and its "Directions". The "Origin" is the physical position of the
    pixel whose "Index" is all zeros. The "Direction" of an image is a
    matrix whose columns indicate the direction in physical space that
    each dimension of the image traverses. The first column defines the
    direction that the fastest moving index in the image traverses in
    physical space while the last column defines the direction that the
    slowest moving index in the image traverses in physical space.

    The extent of an image is defined by the pixel spacing and a set of
    regions. The "Spacing" is the size of a pixel in physical space
    along each dimension. Regions describe a portion of an image grid via
    a starting index for the image array and a size (or number of pixels)
    in each dimension. The ivar LargestPossibleRegion defines the size and
    starting index of the image dataset. The entire image dataset,
    however, may not be resident in memory. The region of the image that
    is resident in memory is defined by the "BufferedRegion". The Buffer
    is a contiguous block of memory. The third set of meta-data defines a
    region of interest, called the "RequestedRegion". The
    RequestedRegion is used by the pipeline execution model to define what
    a filter is requested to produce.

    [RegionIndex, RegionSize] C [BufferIndex, BufferSize] C [ImageIndex,
    ImageSize]

    ImageBase provides all the methods for converting between the physical
    space and index coordinate frames. TransformIndexToPhysicalPoint()
    converts an Index in the pixel array into its coordinates in physical
    space. TransformPhysicalPointToIndex() converts a position in physical
    space into an Index into the pixel array (using rounding). Subpixel
    locations are supported by methods that convert to and from
    ContinuousIndex types.

    ImageBase also provides helper routines for the ImageIterators which
    convert an Index to an offset in memory from the first pixel address
    as well as covert an offset in memory from the first pixel address to
    an Index. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageBase5___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageBase5_Clone)
    GetImageDimension = _swig_new_static_method(_itkImagePython.itkImageBase5_GetImageDimension)
    SetOrigin = _swig_new_instance_method(_itkImagePython.itkImageBase5_SetOrigin)
    __SetDirection_orig__ = _swig_new_instance_method(_itkImagePython.itkImageBase5___SetDirection_orig__)
    GetDirection = _swig_new_instance_method(_itkImagePython.itkImageBase5_GetDirection)
    GetInverseDirection = _swig_new_instance_method(_itkImagePython.itkImageBase5_GetInverseDirection)
    GetSpacing = _swig_new_instance_method(_itkImagePython.itkImageBase5_GetSpacing)
    GetOrigin = _swig_new_instance_method(_itkImagePython.itkImageBase5_GetOrigin)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageBase5_Allocate)
    SetLargestPossibleRegion = _swig_new_instance_method(_itkImagePython.itkImageBase5_SetLargestPossibleRegion)
    __GetLargestPossibleRegion_orig__ = _swig_new_instance_method(_itkImagePython.itkImageBase5___GetLargestPossibleRegion_orig__)
    SetBufferedRegion = _swig_new_instance_method(_itkImagePython.itkImageBase5_SetBufferedRegion)
    __GetBufferedRegion_orig__ = _swig_new_instance_method(_itkImagePython.itkImageBase5___GetBufferedRegion_orig__)
    SetRequestedRegion = _swig_new_instance_method(_itkImagePython.itkImageBase5_SetRequestedRegion)
    __GetRequestedRegion_orig__ = _swig_new_instance_method(_itkImagePython.itkImageBase5___GetRequestedRegion_orig__)
    SetRegions = _swig_new_instance_method(_itkImagePython.itkImageBase5_SetRegions)
    GetOffsetTable = _swig_new_instance_method(_itkImagePython.itkImageBase5_GetOffsetTable)
    ComputeOffset = _swig_new_instance_method(_itkImagePython.itkImageBase5_ComputeOffset)
    ComputeIndex = _swig_new_instance_method(_itkImagePython.itkImageBase5_ComputeIndex)
    SetSpacing = _swig_new_instance_method(_itkImagePython.itkImageBase5_SetSpacing)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageBase5_Graft)
    GetNumberOfComponentsPerPixel = _swig_new_instance_method(_itkImagePython.itkImageBase5_GetNumberOfComponentsPerPixel)
    SetNumberOfComponentsPerPixel = _swig_new_instance_method(_itkImagePython.itkImageBase5_SetNumberOfComponentsPerPixel)
    __swig_destroy__ = _itkImagePython.delete_itkImageBase5
    cast = _swig_new_static_method(_itkImagePython.itkImageBase5_cast)

    def GetBufferedRegion(self):
        var = self.__GetBufferedRegion_orig__()
        var_copy = type(var)(var)
        return var_copy


    def GetLargestPossibleRegion(self):
        var = self.__GetLargestPossibleRegion_orig__()
        var_copy = type(var)(var)
        return var_copy


    def GetRequestedRegion(self):
        var = self.__GetRequestedRegion_orig__()
        var_copy = type(var)(var)
        return var_copy

    TransformPhysicalPointToIndex = _swig_new_instance_method(_itkImagePython.itkImageBase5_TransformPhysicalPointToIndex)
    TransformPhysicalPointToContinuousIndex = _swig_new_instance_method(_itkImagePython.itkImageBase5_TransformPhysicalPointToContinuousIndex)
    TransformContinuousIndexToPhysicalPoint = _swig_new_instance_method(_itkImagePython.itkImageBase5_TransformContinuousIndexToPhysicalPoint)
    TransformIndexToPhysicalPoint = _swig_new_instance_method(_itkImagePython.itkImageBase5_TransformIndexToPhysicalPoint)

    def _SetBase(self, base):
        """Internal method to keep a reference when creating a view of a NumPy array."""
        self.base = base

    @property
    def ndim(self):
        """Equivalant to the np.ndarray ndim attribute when converted
        to an image with itk.array_view_from_image."""
        spatial_dims = self.GetImageDimension()
        if self.GetNumberOfComponentsPerPixel() > 1:
            return spatial_dims + 1
        else:
            return spatial_dims

    @property
    def shape(self):
        """Equivalant to the np.ndarray shape attribute when converted
        to an image with itk.array_view_from_image."""
        itksize = self.GetLargestPossibleRegion().GetSize()
        dim = len(itksize)
        result = [int(itksize[idx]) for idx in range(dim)]

        if(self.GetNumberOfComponentsPerPixel() > 1):
            result = [self.GetNumberOfComponentsPerPixel(), ] + result
        result.reverse()
        return tuple(result)

    @property
    def dtype(self):
        """Equivalant to the np.ndarray dtype attribute when converted
        to an image with itk.array_view_from_image."""
        import itk
        first_template_arg = itk.template(self)[1][0]
        if hasattr(first_template_arg, 'dtype'):
            return first_template_arg.dtype
        else:
#Multi-component pixel types, e.g. Vector,
#CovariantVector, etc.
            return itk.template(first_template_arg)[1][0].dtype

    def astype(self, pixel_type):
        """Cast the image to the provided itk pixel type or equivalent NumPy dtype."""
        import itk
        import numpy as np
        from itk.support import types

#if both a numpy dtype and a ctype exist, use the latter.
        if type(pixel_type) is type:
            c_pixel_type = types.itkCType.GetCTypeForDType(pixel_type)
            if c_pixel_type is not None:
                pixel_type = c_pixel_type

#input_image_template is Image or VectorImage
        (input_image_template, (input_pixel_type, input_image_dimension)) = itk.template(self)

        if input_pixel_type is pixel_type:
            return self
        OutputImageType = input_image_template[pixel_type, input_image_dimension]
        cast = itk.cast_image_filter(self, ttype=(type(self), OutputImageType))
        return cast

    def SetDirection(self, direction):
        from itk.support import helpers
        if helpers.is_arraylike(direction):
            import itk
            import numpy as np

            array = np.asarray(direction).astype(np.float64)
            dimension = self.GetImageDimension()
            for dim in array.shape:
                if dim != dimension:
                    raise ValueError('Array does not have the expected shape')
            matrix = itk.matrix_from_array(array)
            self.__SetDirection_orig__(matrix)
        else:
            self.__SetDirection_orig__(direction)

    def keys(self):
        """Return keys related to the image's metadata.

        These keys are used in the dictionary resulting from dict(image).

        These keys include MetaDataDictionary keys along with
        'origin', 'spacing', and 'direction' keys, which
        correspond to the image's Origin, Spacing, and Direction. However,
        they are in (z, y, x) order as opposed to (x, y, z) order to
        correspond to the indexing of the shape of the pixel buffer
        array resulting from np.array(image).
        """
        meta_keys = self.GetMetaDataDictionary().GetKeys()
#Ignore deprecated, legacy members that cause issues
        result = list(filter(lambda k: not k.startswith('ITK_original'), meta_keys))
        result.extend(['origin', 'spacing', 'direction'])
        return result

    def __getitem__(self, key):
        """Access metadata keys, see help(image.keys), for string
        keys, otherwise provide NumPy indexing to the pixel buffer
        array view. The index order follows NumPy array indexing
        order, i.e. [z, y, x] versus [x, y, z]."""
        import itk
        if isinstance(key, str):
            import numpy as np
            if key == 'origin':
                return np.flip(np.asarray(self.GetOrigin()), axis=None)
            elif key == 'spacing':
                return np.flip(np.asarray(self.GetSpacing()), axis=None)
            elif key == 'direction':
                return np.flip(itk.array_from_matrix(self.GetDirection()), axis=None)
            else:
                return self.GetMetaDataDictionary()[key]
        else:
            return itk.array_view_from_image(self).__getitem__(key)

    def __setitem__(self, key, value):
        """Set metadata keys, see help(image.keys), for string
        keys, otherwise provide NumPy indexing to the pixel buffer
        array view. The index order follows NumPy array indexing
        order, i.e. [z, y, x] versus [x, y, z]."""
        if isinstance(key, str):
            import numpy as np
            if key == 'origin':
                self.SetOrigin(np.flip(value, axis=None))
            elif key == 'spacing':
                self.SetSpacing(np.flip(value, axis=None))
            elif key == 'direction':
                self.SetDirection(np.flip(value, axis=None))
            else:
                self.GetMetaDataDictionary()[key] = value
        else:
            import itk
            itk.array_view_from_image(self).__setitem__(key, value)



    def New(*args, **kargs):
        """New() -> itkImageBase5

        Create a new object of the class itkImageBase5 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageBase5.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageBase5.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageBase5.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageBase5 in _itkImagePython:
_itkImagePython.itkImageBase5_swigregister(itkImageBase5)
itkImageBase5___New_orig__ = _itkImagePython.itkImageBase5___New_orig__
itkImageBase5_GetImageDimension = _itkImagePython.itkImageBase5_GetImageDimension
itkImageBase5_cast = _itkImagePython.itkImageBase5_cast


def itkImageCD2_New():
    return itkImageCD2.New()

class itkImageCD2(itkImageBase2):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageCD2___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageCD2_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageCD2_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageCD2_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageCD2_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageCD2_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageCD2_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageCD2_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageCD2_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageCD2_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageCD2_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageCD2_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageCD2
    cast = _swig_new_static_method(_itkImagePython.itkImageCD2_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageCD2

        Create a new object of the class itkImageCD2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageCD2.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageCD2.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageCD2.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageCD2 in _itkImagePython:
_itkImagePython.itkImageCD2_swigregister(itkImageCD2)
itkImageCD2___New_orig__ = _itkImagePython.itkImageCD2___New_orig__
itkImageCD2_cast = _itkImagePython.itkImageCD2_cast


def itkImageCD3_New():
    return itkImageCD3.New()

class itkImageCD3(itkImageBase3):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageCD3___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageCD3_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageCD3_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageCD3_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageCD3_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageCD3_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageCD3_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageCD3_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageCD3_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageCD3_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageCD3_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageCD3_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageCD3
    cast = _swig_new_static_method(_itkImagePython.itkImageCD3_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageCD3

        Create a new object of the class itkImageCD3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageCD3.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageCD3.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageCD3.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageCD3 in _itkImagePython:
_itkImagePython.itkImageCD3_swigregister(itkImageCD3)
itkImageCD3___New_orig__ = _itkImagePython.itkImageCD3___New_orig__
itkImageCD3_cast = _itkImagePython.itkImageCD3_cast


def itkImageCD4_New():
    return itkImageCD4.New()

class itkImageCD4(itkImageBase4):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageCD4___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageCD4_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageCD4_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageCD4_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageCD4_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageCD4_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageCD4_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageCD4_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageCD4_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageCD4_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageCD4_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageCD4_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageCD4
    cast = _swig_new_static_method(_itkImagePython.itkImageCD4_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageCD4

        Create a new object of the class itkImageCD4 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageCD4.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageCD4.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageCD4.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageCD4 in _itkImagePython:
_itkImagePython.itkImageCD4_swigregister(itkImageCD4)
itkImageCD4___New_orig__ = _itkImagePython.itkImageCD4___New_orig__
itkImageCD4_cast = _itkImagePython.itkImageCD4_cast


def itkImageCF2_New():
    return itkImageCF2.New()

class itkImageCF2(itkImageBase2):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageCF2___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageCF2_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageCF2_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageCF2_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageCF2_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageCF2_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageCF2_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageCF2_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageCF2_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageCF2_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageCF2_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageCF2_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageCF2
    cast = _swig_new_static_method(_itkImagePython.itkImageCF2_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageCF2

        Create a new object of the class itkImageCF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageCF2.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageCF2.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageCF2.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageCF2 in _itkImagePython:
_itkImagePython.itkImageCF2_swigregister(itkImageCF2)
itkImageCF2___New_orig__ = _itkImagePython.itkImageCF2___New_orig__
itkImageCF2_cast = _itkImagePython.itkImageCF2_cast


def itkImageCF3_New():
    return itkImageCF3.New()

class itkImageCF3(itkImageBase3):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageCF3___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageCF3_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageCF3_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageCF3_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageCF3_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageCF3_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageCF3_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageCF3_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageCF3_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageCF3_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageCF3_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageCF3_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageCF3
    cast = _swig_new_static_method(_itkImagePython.itkImageCF3_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageCF3

        Create a new object of the class itkImageCF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageCF3.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageCF3.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageCF3.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageCF3 in _itkImagePython:
_itkImagePython.itkImageCF3_swigregister(itkImageCF3)
itkImageCF3___New_orig__ = _itkImagePython.itkImageCF3___New_orig__
itkImageCF3_cast = _itkImagePython.itkImageCF3_cast


def itkImageCF4_New():
    return itkImageCF4.New()

class itkImageCF4(itkImageBase4):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageCF4___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageCF4_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageCF4_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageCF4_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageCF4_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageCF4_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageCF4_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageCF4_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageCF4_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageCF4_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageCF4_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageCF4_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageCF4
    cast = _swig_new_static_method(_itkImagePython.itkImageCF4_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageCF4

        Create a new object of the class itkImageCF4 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageCF4.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageCF4.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageCF4.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageCF4 in _itkImagePython:
_itkImagePython.itkImageCF4_swigregister(itkImageCF4)
itkImageCF4___New_orig__ = _itkImagePython.itkImageCF4___New_orig__
itkImageCF4_cast = _itkImagePython.itkImageCF4_cast


def itkImageCVD22_New():
    return itkImageCVD22.New()

class itkImageCVD22(itkImageBase2):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageCVD22___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageCVD22_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageCVD22_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageCVD22_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageCVD22_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageCVD22_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageCVD22_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageCVD22_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageCVD22_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageCVD22_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageCVD22_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageCVD22_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageCVD22
    cast = _swig_new_static_method(_itkImagePython.itkImageCVD22_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageCVD22

        Create a new object of the class itkImageCVD22 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageCVD22.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageCVD22.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageCVD22.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageCVD22 in _itkImagePython:
_itkImagePython.itkImageCVD22_swigregister(itkImageCVD22)
itkImageCVD22___New_orig__ = _itkImagePython.itkImageCVD22___New_orig__
itkImageCVD22_cast = _itkImagePython.itkImageCVD22_cast


def itkImageCVD23_New():
    return itkImageCVD23.New()

class itkImageCVD23(itkImageBase3):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageCVD23___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageCVD23_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageCVD23_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageCVD23_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageCVD23_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageCVD23_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageCVD23_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageCVD23_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageCVD23_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageCVD23_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageCVD23_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageCVD23_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageCVD23
    cast = _swig_new_static_method(_itkImagePython.itkImageCVD23_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageCVD23

        Create a new object of the class itkImageCVD23 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageCVD23.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageCVD23.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageCVD23.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageCVD23 in _itkImagePython:
_itkImagePython.itkImageCVD23_swigregister(itkImageCVD23)
itkImageCVD23___New_orig__ = _itkImagePython.itkImageCVD23___New_orig__
itkImageCVD23_cast = _itkImagePython.itkImageCVD23_cast


def itkImageCVD24_New():
    return itkImageCVD24.New()

class itkImageCVD24(itkImageBase4):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageCVD24___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageCVD24_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageCVD24_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageCVD24_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageCVD24_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageCVD24_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageCVD24_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageCVD24_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageCVD24_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageCVD24_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageCVD24_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageCVD24_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageCVD24
    cast = _swig_new_static_method(_itkImagePython.itkImageCVD24_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageCVD24

        Create a new object of the class itkImageCVD24 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageCVD24.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageCVD24.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageCVD24.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageCVD24 in _itkImagePython:
_itkImagePython.itkImageCVD24_swigregister(itkImageCVD24)
itkImageCVD24___New_orig__ = _itkImagePython.itkImageCVD24___New_orig__
itkImageCVD24_cast = _itkImagePython.itkImageCVD24_cast


def itkImageCVD32_New():
    return itkImageCVD32.New()

class itkImageCVD32(itkImageBase2):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageCVD32___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageCVD32_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageCVD32_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageCVD32_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageCVD32_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageCVD32_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageCVD32_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageCVD32_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageCVD32_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageCVD32_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageCVD32_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageCVD32_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageCVD32
    cast = _swig_new_static_method(_itkImagePython.itkImageCVD32_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageCVD32

        Create a new object of the class itkImageCVD32 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageCVD32.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageCVD32.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageCVD32.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageCVD32 in _itkImagePython:
_itkImagePython.itkImageCVD32_swigregister(itkImageCVD32)
itkImageCVD32___New_orig__ = _itkImagePython.itkImageCVD32___New_orig__
itkImageCVD32_cast = _itkImagePython.itkImageCVD32_cast


def itkImageCVD33_New():
    return itkImageCVD33.New()

class itkImageCVD33(itkImageBase3):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageCVD33___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageCVD33_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageCVD33_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageCVD33_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageCVD33_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageCVD33_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageCVD33_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageCVD33_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageCVD33_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageCVD33_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageCVD33_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageCVD33_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageCVD33
    cast = _swig_new_static_method(_itkImagePython.itkImageCVD33_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageCVD33

        Create a new object of the class itkImageCVD33 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageCVD33.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageCVD33.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageCVD33.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageCVD33 in _itkImagePython:
_itkImagePython.itkImageCVD33_swigregister(itkImageCVD33)
itkImageCVD33___New_orig__ = _itkImagePython.itkImageCVD33___New_orig__
itkImageCVD33_cast = _itkImagePython.itkImageCVD33_cast


def itkImageCVD34_New():
    return itkImageCVD34.New()

class itkImageCVD34(itkImageBase4):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageCVD34___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageCVD34_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageCVD34_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageCVD34_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageCVD34_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageCVD34_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageCVD34_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageCVD34_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageCVD34_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageCVD34_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageCVD34_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageCVD34_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageCVD34
    cast = _swig_new_static_method(_itkImagePython.itkImageCVD34_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageCVD34

        Create a new object of the class itkImageCVD34 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageCVD34.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageCVD34.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageCVD34.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageCVD34 in _itkImagePython:
_itkImagePython.itkImageCVD34_swigregister(itkImageCVD34)
itkImageCVD34___New_orig__ = _itkImagePython.itkImageCVD34___New_orig__
itkImageCVD34_cast = _itkImagePython.itkImageCVD34_cast


def itkImageCVD42_New():
    return itkImageCVD42.New()

class itkImageCVD42(itkImageBase2):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageCVD42___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageCVD42_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageCVD42_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageCVD42_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageCVD42_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageCVD42_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageCVD42_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageCVD42_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageCVD42_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageCVD42_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageCVD42_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageCVD42_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageCVD42
    cast = _swig_new_static_method(_itkImagePython.itkImageCVD42_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageCVD42

        Create a new object of the class itkImageCVD42 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageCVD42.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageCVD42.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageCVD42.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageCVD42 in _itkImagePython:
_itkImagePython.itkImageCVD42_swigregister(itkImageCVD42)
itkImageCVD42___New_orig__ = _itkImagePython.itkImageCVD42___New_orig__
itkImageCVD42_cast = _itkImagePython.itkImageCVD42_cast


def itkImageCVD43_New():
    return itkImageCVD43.New()

class itkImageCVD43(itkImageBase3):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageCVD43___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageCVD43_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageCVD43_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageCVD43_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageCVD43_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageCVD43_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageCVD43_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageCVD43_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageCVD43_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageCVD43_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageCVD43_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageCVD43_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageCVD43
    cast = _swig_new_static_method(_itkImagePython.itkImageCVD43_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageCVD43

        Create a new object of the class itkImageCVD43 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageCVD43.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageCVD43.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageCVD43.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageCVD43 in _itkImagePython:
_itkImagePython.itkImageCVD43_swigregister(itkImageCVD43)
itkImageCVD43___New_orig__ = _itkImagePython.itkImageCVD43___New_orig__
itkImageCVD43_cast = _itkImagePython.itkImageCVD43_cast


def itkImageCVD44_New():
    return itkImageCVD44.New()

class itkImageCVD44(itkImageBase4):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageCVD44___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageCVD44_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageCVD44_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageCVD44_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageCVD44_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageCVD44_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageCVD44_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageCVD44_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageCVD44_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageCVD44_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageCVD44_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageCVD44_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageCVD44
    cast = _swig_new_static_method(_itkImagePython.itkImageCVD44_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageCVD44

        Create a new object of the class itkImageCVD44 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageCVD44.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageCVD44.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageCVD44.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageCVD44 in _itkImagePython:
_itkImagePython.itkImageCVD44_swigregister(itkImageCVD44)
itkImageCVD44___New_orig__ = _itkImagePython.itkImageCVD44___New_orig__
itkImageCVD44_cast = _itkImagePython.itkImageCVD44_cast


def itkImageCVF22_New():
    return itkImageCVF22.New()

class itkImageCVF22(itkImageBase2):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageCVF22___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageCVF22_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageCVF22_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageCVF22_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageCVF22_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageCVF22_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageCVF22_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageCVF22_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageCVF22_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageCVF22_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageCVF22_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageCVF22_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageCVF22
    cast = _swig_new_static_method(_itkImagePython.itkImageCVF22_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageCVF22

        Create a new object of the class itkImageCVF22 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageCVF22.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageCVF22.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageCVF22.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageCVF22 in _itkImagePython:
_itkImagePython.itkImageCVF22_swigregister(itkImageCVF22)
itkImageCVF22___New_orig__ = _itkImagePython.itkImageCVF22___New_orig__
itkImageCVF22_cast = _itkImagePython.itkImageCVF22_cast


def itkImageCVF23_New():
    return itkImageCVF23.New()

class itkImageCVF23(itkImageBase3):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageCVF23___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageCVF23_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageCVF23_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageCVF23_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageCVF23_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageCVF23_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageCVF23_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageCVF23_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageCVF23_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageCVF23_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageCVF23_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageCVF23_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageCVF23
    cast = _swig_new_static_method(_itkImagePython.itkImageCVF23_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageCVF23

        Create a new object of the class itkImageCVF23 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageCVF23.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageCVF23.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageCVF23.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageCVF23 in _itkImagePython:
_itkImagePython.itkImageCVF23_swigregister(itkImageCVF23)
itkImageCVF23___New_orig__ = _itkImagePython.itkImageCVF23___New_orig__
itkImageCVF23_cast = _itkImagePython.itkImageCVF23_cast


def itkImageCVF24_New():
    return itkImageCVF24.New()

class itkImageCVF24(itkImageBase4):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageCVF24___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageCVF24_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageCVF24_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageCVF24_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageCVF24_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageCVF24_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageCVF24_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageCVF24_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageCVF24_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageCVF24_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageCVF24_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageCVF24_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageCVF24
    cast = _swig_new_static_method(_itkImagePython.itkImageCVF24_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageCVF24

        Create a new object of the class itkImageCVF24 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageCVF24.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageCVF24.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageCVF24.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageCVF24 in _itkImagePython:
_itkImagePython.itkImageCVF24_swigregister(itkImageCVF24)
itkImageCVF24___New_orig__ = _itkImagePython.itkImageCVF24___New_orig__
itkImageCVF24_cast = _itkImagePython.itkImageCVF24_cast


def itkImageCVF32_New():
    return itkImageCVF32.New()

class itkImageCVF32(itkImageBase2):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageCVF32___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageCVF32_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageCVF32_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageCVF32_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageCVF32_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageCVF32_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageCVF32_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageCVF32_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageCVF32_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageCVF32_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageCVF32_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageCVF32_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageCVF32
    cast = _swig_new_static_method(_itkImagePython.itkImageCVF32_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageCVF32

        Create a new object of the class itkImageCVF32 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageCVF32.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageCVF32.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageCVF32.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageCVF32 in _itkImagePython:
_itkImagePython.itkImageCVF32_swigregister(itkImageCVF32)
itkImageCVF32___New_orig__ = _itkImagePython.itkImageCVF32___New_orig__
itkImageCVF32_cast = _itkImagePython.itkImageCVF32_cast


def itkImageCVF33_New():
    return itkImageCVF33.New()

class itkImageCVF33(itkImageBase3):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageCVF33___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageCVF33_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageCVF33_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageCVF33_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageCVF33_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageCVF33_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageCVF33_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageCVF33_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageCVF33_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageCVF33_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageCVF33_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageCVF33_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageCVF33
    cast = _swig_new_static_method(_itkImagePython.itkImageCVF33_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageCVF33

        Create a new object of the class itkImageCVF33 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageCVF33.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageCVF33.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageCVF33.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageCVF33 in _itkImagePython:
_itkImagePython.itkImageCVF33_swigregister(itkImageCVF33)
itkImageCVF33___New_orig__ = _itkImagePython.itkImageCVF33___New_orig__
itkImageCVF33_cast = _itkImagePython.itkImageCVF33_cast


def itkImageCVF34_New():
    return itkImageCVF34.New()

class itkImageCVF34(itkImageBase4):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageCVF34___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageCVF34_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageCVF34_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageCVF34_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageCVF34_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageCVF34_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageCVF34_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageCVF34_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageCVF34_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageCVF34_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageCVF34_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageCVF34_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageCVF34
    cast = _swig_new_static_method(_itkImagePython.itkImageCVF34_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageCVF34

        Create a new object of the class itkImageCVF34 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageCVF34.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageCVF34.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageCVF34.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageCVF34 in _itkImagePython:
_itkImagePython.itkImageCVF34_swigregister(itkImageCVF34)
itkImageCVF34___New_orig__ = _itkImagePython.itkImageCVF34___New_orig__
itkImageCVF34_cast = _itkImagePython.itkImageCVF34_cast


def itkImageCVF42_New():
    return itkImageCVF42.New()

class itkImageCVF42(itkImageBase2):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageCVF42___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageCVF42_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageCVF42_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageCVF42_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageCVF42_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageCVF42_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageCVF42_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageCVF42_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageCVF42_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageCVF42_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageCVF42_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageCVF42_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageCVF42
    cast = _swig_new_static_method(_itkImagePython.itkImageCVF42_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageCVF42

        Create a new object of the class itkImageCVF42 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageCVF42.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageCVF42.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageCVF42.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageCVF42 in _itkImagePython:
_itkImagePython.itkImageCVF42_swigregister(itkImageCVF42)
itkImageCVF42___New_orig__ = _itkImagePython.itkImageCVF42___New_orig__
itkImageCVF42_cast = _itkImagePython.itkImageCVF42_cast


def itkImageCVF43_New():
    return itkImageCVF43.New()

class itkImageCVF43(itkImageBase3):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageCVF43___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageCVF43_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageCVF43_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageCVF43_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageCVF43_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageCVF43_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageCVF43_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageCVF43_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageCVF43_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageCVF43_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageCVF43_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageCVF43_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageCVF43
    cast = _swig_new_static_method(_itkImagePython.itkImageCVF43_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageCVF43

        Create a new object of the class itkImageCVF43 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageCVF43.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageCVF43.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageCVF43.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageCVF43 in _itkImagePython:
_itkImagePython.itkImageCVF43_swigregister(itkImageCVF43)
itkImageCVF43___New_orig__ = _itkImagePython.itkImageCVF43___New_orig__
itkImageCVF43_cast = _itkImagePython.itkImageCVF43_cast


def itkImageCVF44_New():
    return itkImageCVF44.New()

class itkImageCVF44(itkImageBase4):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageCVF44___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageCVF44_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageCVF44_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageCVF44_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageCVF44_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageCVF44_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageCVF44_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageCVF44_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageCVF44_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageCVF44_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageCVF44_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageCVF44_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageCVF44
    cast = _swig_new_static_method(_itkImagePython.itkImageCVF44_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageCVF44

        Create a new object of the class itkImageCVF44 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageCVF44.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageCVF44.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageCVF44.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageCVF44 in _itkImagePython:
_itkImagePython.itkImageCVF44_swigregister(itkImageCVF44)
itkImageCVF44___New_orig__ = _itkImagePython.itkImageCVF44___New_orig__
itkImageCVF44_cast = _itkImagePython.itkImageCVF44_cast


def itkImageD2_New():
    return itkImageD2.New()

class itkImageD2(itkImageBase2):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageD2___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageD2_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageD2_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageD2_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageD2_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageD2_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageD2_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageD2_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageD2_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageD2_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageD2_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageD2_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageD2
    cast = _swig_new_static_method(_itkImagePython.itkImageD2_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageD2

        Create a new object of the class itkImageD2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageD2.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageD2.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageD2.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageD2 in _itkImagePython:
_itkImagePython.itkImageD2_swigregister(itkImageD2)
itkImageD2___New_orig__ = _itkImagePython.itkImageD2___New_orig__
itkImageD2_cast = _itkImagePython.itkImageD2_cast


def itkImageD3_New():
    return itkImageD3.New()

class itkImageD3(itkImageBase3):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageD3___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageD3_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageD3_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageD3_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageD3_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageD3_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageD3_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageD3_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageD3_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageD3_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageD3_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageD3_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageD3
    cast = _swig_new_static_method(_itkImagePython.itkImageD3_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageD3

        Create a new object of the class itkImageD3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageD3.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageD3.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageD3.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageD3 in _itkImagePython:
_itkImagePython.itkImageD3_swigregister(itkImageD3)
itkImageD3___New_orig__ = _itkImagePython.itkImageD3___New_orig__
itkImageD3_cast = _itkImagePython.itkImageD3_cast


def itkImageD4_New():
    return itkImageD4.New()

class itkImageD4(itkImageBase4):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageD4___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageD4_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageD4_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageD4_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageD4_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageD4_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageD4_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageD4_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageD4_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageD4_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageD4_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageD4_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageD4
    cast = _swig_new_static_method(_itkImagePython.itkImageD4_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageD4

        Create a new object of the class itkImageD4 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageD4.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageD4.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageD4.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageD4 in _itkImagePython:
_itkImagePython.itkImageD4_swigregister(itkImageD4)
itkImageD4___New_orig__ = _itkImagePython.itkImageD4___New_orig__
itkImageD4_cast = _itkImagePython.itkImageD4_cast


def itkImageF2_New():
    return itkImageF2.New()

class itkImageF2(itkImageBase2):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageF2___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageF2_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageF2_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageF2_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageF2_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageF2_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageF2_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageF2_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageF2_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageF2_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageF2_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageF2_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageF2
    cast = _swig_new_static_method(_itkImagePython.itkImageF2_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageF2

        Create a new object of the class itkImageF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageF2.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageF2.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageF2.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageF2 in _itkImagePython:
_itkImagePython.itkImageF2_swigregister(itkImageF2)
itkImageF2___New_orig__ = _itkImagePython.itkImageF2___New_orig__
itkImageF2_cast = _itkImagePython.itkImageF2_cast


def itkImageF3_New():
    return itkImageF3.New()

class itkImageF3(itkImageBase3):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageF3___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageF3_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageF3_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageF3_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageF3_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageF3_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageF3_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageF3_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageF3_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageF3_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageF3_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageF3_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageF3
    cast = _swig_new_static_method(_itkImagePython.itkImageF3_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageF3

        Create a new object of the class itkImageF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageF3.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageF3.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageF3.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageF3 in _itkImagePython:
_itkImagePython.itkImageF3_swigregister(itkImageF3)
itkImageF3___New_orig__ = _itkImagePython.itkImageF3___New_orig__
itkImageF3_cast = _itkImagePython.itkImageF3_cast


def itkImageF4_New():
    return itkImageF4.New()

class itkImageF4(itkImageBase4):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageF4___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageF4_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageF4_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageF4_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageF4_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageF4_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageF4_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageF4_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageF4_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageF4_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageF4_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageF4_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageF4
    cast = _swig_new_static_method(_itkImagePython.itkImageF4_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageF4

        Create a new object of the class itkImageF4 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageF4.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageF4.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageF4.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageF4 in _itkImagePython:
_itkImagePython.itkImageF4_swigregister(itkImageF4)
itkImageF4___New_orig__ = _itkImagePython.itkImageF4___New_orig__
itkImageF4_cast = _itkImagePython.itkImageF4_cast


def itkImageFAD22_New():
    return itkImageFAD22.New()

class itkImageFAD22(itkImageBase2):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageFAD22___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageFAD22_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageFAD22_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageFAD22_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageFAD22_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageFAD22_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageFAD22_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageFAD22_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageFAD22_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageFAD22_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageFAD22_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageFAD22_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageFAD22
    cast = _swig_new_static_method(_itkImagePython.itkImageFAD22_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageFAD22

        Create a new object of the class itkImageFAD22 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageFAD22.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageFAD22.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageFAD22.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageFAD22 in _itkImagePython:
_itkImagePython.itkImageFAD22_swigregister(itkImageFAD22)
itkImageFAD22___New_orig__ = _itkImagePython.itkImageFAD22___New_orig__
itkImageFAD22_cast = _itkImagePython.itkImageFAD22_cast


def itkImageFAD33_New():
    return itkImageFAD33.New()

class itkImageFAD33(itkImageBase3):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageFAD33___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageFAD33_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageFAD33_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageFAD33_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageFAD33_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageFAD33_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageFAD33_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageFAD33_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageFAD33_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageFAD33_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageFAD33_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageFAD33_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageFAD33
    cast = _swig_new_static_method(_itkImagePython.itkImageFAD33_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageFAD33

        Create a new object of the class itkImageFAD33 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageFAD33.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageFAD33.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageFAD33.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageFAD33 in _itkImagePython:
_itkImagePython.itkImageFAD33_swigregister(itkImageFAD33)
itkImageFAD33___New_orig__ = _itkImagePython.itkImageFAD33___New_orig__
itkImageFAD33_cast = _itkImagePython.itkImageFAD33_cast


def itkImageFAD44_New():
    return itkImageFAD44.New()

class itkImageFAD44(itkImageBase4):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageFAD44___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageFAD44_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageFAD44_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageFAD44_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageFAD44_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageFAD44_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageFAD44_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageFAD44_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageFAD44_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageFAD44_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageFAD44_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageFAD44_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageFAD44
    cast = _swig_new_static_method(_itkImagePython.itkImageFAD44_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageFAD44

        Create a new object of the class itkImageFAD44 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageFAD44.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageFAD44.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageFAD44.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageFAD44 in _itkImagePython:
_itkImagePython.itkImageFAD44_swigregister(itkImageFAD44)
itkImageFAD44___New_orig__ = _itkImagePython.itkImageFAD44___New_orig__
itkImageFAD44_cast = _itkImagePython.itkImageFAD44_cast


def itkImageFAF22_New():
    return itkImageFAF22.New()

class itkImageFAF22(itkImageBase2):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageFAF22___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageFAF22_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageFAF22_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageFAF22_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageFAF22_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageFAF22_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageFAF22_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageFAF22_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageFAF22_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageFAF22_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageFAF22_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageFAF22_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageFAF22
    cast = _swig_new_static_method(_itkImagePython.itkImageFAF22_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageFAF22

        Create a new object of the class itkImageFAF22 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageFAF22.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageFAF22.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageFAF22.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageFAF22 in _itkImagePython:
_itkImagePython.itkImageFAF22_swigregister(itkImageFAF22)
itkImageFAF22___New_orig__ = _itkImagePython.itkImageFAF22___New_orig__
itkImageFAF22_cast = _itkImagePython.itkImageFAF22_cast


def itkImageFAF33_New():
    return itkImageFAF33.New()

class itkImageFAF33(itkImageBase3):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageFAF33___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageFAF33_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageFAF33_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageFAF33_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageFAF33_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageFAF33_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageFAF33_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageFAF33_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageFAF33_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageFAF33_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageFAF33_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageFAF33_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageFAF33
    cast = _swig_new_static_method(_itkImagePython.itkImageFAF33_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageFAF33

        Create a new object of the class itkImageFAF33 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageFAF33.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageFAF33.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageFAF33.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageFAF33 in _itkImagePython:
_itkImagePython.itkImageFAF33_swigregister(itkImageFAF33)
itkImageFAF33___New_orig__ = _itkImagePython.itkImageFAF33___New_orig__
itkImageFAF33_cast = _itkImagePython.itkImageFAF33_cast


def itkImageFAF44_New():
    return itkImageFAF44.New()

class itkImageFAF44(itkImageBase4):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageFAF44___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageFAF44_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageFAF44_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageFAF44_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageFAF44_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageFAF44_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageFAF44_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageFAF44_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageFAF44_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageFAF44_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageFAF44_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageFAF44_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageFAF44
    cast = _swig_new_static_method(_itkImagePython.itkImageFAF44_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageFAF44

        Create a new object of the class itkImageFAF44 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageFAF44.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageFAF44.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageFAF44.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageFAF44 in _itkImagePython:
_itkImagePython.itkImageFAF44_swigregister(itkImageFAF44)
itkImageFAF44___New_orig__ = _itkImagePython.itkImageFAF44___New_orig__
itkImageFAF44_cast = _itkImagePython.itkImageFAF44_cast


def itkImageO22_New():
    return itkImageO22.New()

class itkImageO22(itkImageBase2):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageO22___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageO22_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageO22_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageO22_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageO22_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageO22_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageO22_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageO22_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageO22_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageO22_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageO22_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageO22_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageO22
    cast = _swig_new_static_method(_itkImagePython.itkImageO22_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageO22

        Create a new object of the class itkImageO22 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageO22.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageO22.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageO22.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageO22 in _itkImagePython:
_itkImagePython.itkImageO22_swigregister(itkImageO22)
itkImageO22___New_orig__ = _itkImagePython.itkImageO22___New_orig__
itkImageO22_cast = _itkImagePython.itkImageO22_cast


def itkImageO33_New():
    return itkImageO33.New()

class itkImageO33(itkImageBase3):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageO33___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageO33_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageO33_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageO33_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageO33_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageO33_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageO33_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageO33_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageO33_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageO33_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageO33_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageO33_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageO33
    cast = _swig_new_static_method(_itkImagePython.itkImageO33_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageO33

        Create a new object of the class itkImageO33 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageO33.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageO33.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageO33.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageO33 in _itkImagePython:
_itkImagePython.itkImageO33_swigregister(itkImageO33)
itkImageO33___New_orig__ = _itkImagePython.itkImageO33___New_orig__
itkImageO33_cast = _itkImagePython.itkImageO33_cast


def itkImageO44_New():
    return itkImageO44.New()

class itkImageO44(itkImageBase4):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageO44___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageO44_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageO44_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageO44_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageO44_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageO44_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageO44_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageO44_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageO44_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageO44_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageO44_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageO44_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageO44
    cast = _swig_new_static_method(_itkImagePython.itkImageO44_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageO44

        Create a new object of the class itkImageO44 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageO44.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageO44.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageO44.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageO44 in _itkImagePython:
_itkImagePython.itkImageO44_swigregister(itkImageO44)
itkImageO44___New_orig__ = _itkImagePython.itkImageO44___New_orig__
itkImageO44_cast = _itkImagePython.itkImageO44_cast


def itkImageRGBAUC2_New():
    return itkImageRGBAUC2.New()

class itkImageRGBAUC2(itkImageBase2):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageRGBAUC2___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageRGBAUC2_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageRGBAUC2_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageRGBAUC2_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageRGBAUC2_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageRGBAUC2_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageRGBAUC2_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageRGBAUC2_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageRGBAUC2_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageRGBAUC2_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageRGBAUC2_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageRGBAUC2_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageRGBAUC2
    cast = _swig_new_static_method(_itkImagePython.itkImageRGBAUC2_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageRGBAUC2

        Create a new object of the class itkImageRGBAUC2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageRGBAUC2.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageRGBAUC2.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageRGBAUC2.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageRGBAUC2 in _itkImagePython:
_itkImagePython.itkImageRGBAUC2_swigregister(itkImageRGBAUC2)
itkImageRGBAUC2___New_orig__ = _itkImagePython.itkImageRGBAUC2___New_orig__
itkImageRGBAUC2_cast = _itkImagePython.itkImageRGBAUC2_cast


def itkImageRGBAUC3_New():
    return itkImageRGBAUC3.New()

class itkImageRGBAUC3(itkImageBase3):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageRGBAUC3___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageRGBAUC3_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageRGBAUC3_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageRGBAUC3_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageRGBAUC3_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageRGBAUC3_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageRGBAUC3_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageRGBAUC3_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageRGBAUC3_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageRGBAUC3_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageRGBAUC3_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageRGBAUC3_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageRGBAUC3
    cast = _swig_new_static_method(_itkImagePython.itkImageRGBAUC3_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageRGBAUC3

        Create a new object of the class itkImageRGBAUC3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageRGBAUC3.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageRGBAUC3.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageRGBAUC3.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageRGBAUC3 in _itkImagePython:
_itkImagePython.itkImageRGBAUC3_swigregister(itkImageRGBAUC3)
itkImageRGBAUC3___New_orig__ = _itkImagePython.itkImageRGBAUC3___New_orig__
itkImageRGBAUC3_cast = _itkImagePython.itkImageRGBAUC3_cast


def itkImageRGBAUC4_New():
    return itkImageRGBAUC4.New()

class itkImageRGBAUC4(itkImageBase4):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageRGBAUC4___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageRGBAUC4_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageRGBAUC4_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageRGBAUC4_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageRGBAUC4_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageRGBAUC4_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageRGBAUC4_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageRGBAUC4_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageRGBAUC4_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageRGBAUC4_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageRGBAUC4_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageRGBAUC4_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageRGBAUC4
    cast = _swig_new_static_method(_itkImagePython.itkImageRGBAUC4_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageRGBAUC4

        Create a new object of the class itkImageRGBAUC4 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageRGBAUC4.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageRGBAUC4.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageRGBAUC4.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageRGBAUC4 in _itkImagePython:
_itkImagePython.itkImageRGBAUC4_swigregister(itkImageRGBAUC4)
itkImageRGBAUC4___New_orig__ = _itkImagePython.itkImageRGBAUC4___New_orig__
itkImageRGBAUC4_cast = _itkImagePython.itkImageRGBAUC4_cast


def itkImageRGBUC2_New():
    return itkImageRGBUC2.New()

class itkImageRGBUC2(itkImageBase2):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageRGBUC2___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageRGBUC2_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageRGBUC2_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageRGBUC2_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageRGBUC2_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageRGBUC2_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageRGBUC2_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageRGBUC2_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageRGBUC2_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageRGBUC2_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageRGBUC2_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageRGBUC2_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageRGBUC2
    cast = _swig_new_static_method(_itkImagePython.itkImageRGBUC2_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageRGBUC2

        Create a new object of the class itkImageRGBUC2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageRGBUC2.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageRGBUC2.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageRGBUC2.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageRGBUC2 in _itkImagePython:
_itkImagePython.itkImageRGBUC2_swigregister(itkImageRGBUC2)
itkImageRGBUC2___New_orig__ = _itkImagePython.itkImageRGBUC2___New_orig__
itkImageRGBUC2_cast = _itkImagePython.itkImageRGBUC2_cast


def itkImageRGBUC3_New():
    return itkImageRGBUC3.New()

class itkImageRGBUC3(itkImageBase3):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageRGBUC3___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageRGBUC3_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageRGBUC3_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageRGBUC3_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageRGBUC3_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageRGBUC3_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageRGBUC3_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageRGBUC3_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageRGBUC3_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageRGBUC3_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageRGBUC3_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageRGBUC3_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageRGBUC3
    cast = _swig_new_static_method(_itkImagePython.itkImageRGBUC3_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageRGBUC3

        Create a new object of the class itkImageRGBUC3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageRGBUC3.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageRGBUC3.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageRGBUC3.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageRGBUC3 in _itkImagePython:
_itkImagePython.itkImageRGBUC3_swigregister(itkImageRGBUC3)
itkImageRGBUC3___New_orig__ = _itkImagePython.itkImageRGBUC3___New_orig__
itkImageRGBUC3_cast = _itkImagePython.itkImageRGBUC3_cast


def itkImageRGBUC4_New():
    return itkImageRGBUC4.New()

class itkImageRGBUC4(itkImageBase4):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageRGBUC4___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageRGBUC4_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageRGBUC4_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageRGBUC4_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageRGBUC4_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageRGBUC4_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageRGBUC4_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageRGBUC4_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageRGBUC4_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageRGBUC4_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageRGBUC4_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageRGBUC4_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageRGBUC4
    cast = _swig_new_static_method(_itkImagePython.itkImageRGBUC4_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageRGBUC4

        Create a new object of the class itkImageRGBUC4 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageRGBUC4.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageRGBUC4.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageRGBUC4.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageRGBUC4 in _itkImagePython:
_itkImagePython.itkImageRGBUC4_swigregister(itkImageRGBUC4)
itkImageRGBUC4___New_orig__ = _itkImagePython.itkImageRGBUC4___New_orig__
itkImageRGBUC4_cast = _itkImagePython.itkImageRGBUC4_cast


def itkImageSI2_New():
    return itkImageSI2.New()

class itkImageSI2(itkImageBase2):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageSI2___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageSI2_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageSI2_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageSI2_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageSI2_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageSI2_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageSI2_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageSI2_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageSI2_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageSI2_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageSI2_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageSI2_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageSI2
    cast = _swig_new_static_method(_itkImagePython.itkImageSI2_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageSI2

        Create a new object of the class itkImageSI2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageSI2.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageSI2.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageSI2.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageSI2 in _itkImagePython:
_itkImagePython.itkImageSI2_swigregister(itkImageSI2)
itkImageSI2___New_orig__ = _itkImagePython.itkImageSI2___New_orig__
itkImageSI2_cast = _itkImagePython.itkImageSI2_cast


def itkImageSI3_New():
    return itkImageSI3.New()

class itkImageSI3(itkImageBase3):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageSI3___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageSI3_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageSI3_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageSI3_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageSI3_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageSI3_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageSI3_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageSI3_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageSI3_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageSI3_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageSI3_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageSI3_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageSI3
    cast = _swig_new_static_method(_itkImagePython.itkImageSI3_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageSI3

        Create a new object of the class itkImageSI3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageSI3.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageSI3.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageSI3.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageSI3 in _itkImagePython:
_itkImagePython.itkImageSI3_swigregister(itkImageSI3)
itkImageSI3___New_orig__ = _itkImagePython.itkImageSI3___New_orig__
itkImageSI3_cast = _itkImagePython.itkImageSI3_cast


def itkImageSI4_New():
    return itkImageSI4.New()

class itkImageSI4(itkImageBase4):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageSI4___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageSI4_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageSI4_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageSI4_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageSI4_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageSI4_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageSI4_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageSI4_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageSI4_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageSI4_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageSI4_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageSI4_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageSI4
    cast = _swig_new_static_method(_itkImagePython.itkImageSI4_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageSI4

        Create a new object of the class itkImageSI4 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageSI4.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageSI4.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageSI4.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageSI4 in _itkImagePython:
_itkImagePython.itkImageSI4_swigregister(itkImageSI4)
itkImageSI4___New_orig__ = _itkImagePython.itkImageSI4___New_orig__
itkImageSI4_cast = _itkImagePython.itkImageSI4_cast


def itkImageSS2_New():
    return itkImageSS2.New()

class itkImageSS2(itkImageBase2):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageSS2___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageSS2_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageSS2_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageSS2_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageSS2_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageSS2_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageSS2_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageSS2_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageSS2_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageSS2_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageSS2_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageSS2_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageSS2
    cast = _swig_new_static_method(_itkImagePython.itkImageSS2_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageSS2

        Create a new object of the class itkImageSS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageSS2.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageSS2.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageSS2.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageSS2 in _itkImagePython:
_itkImagePython.itkImageSS2_swigregister(itkImageSS2)
itkImageSS2___New_orig__ = _itkImagePython.itkImageSS2___New_orig__
itkImageSS2_cast = _itkImagePython.itkImageSS2_cast


def itkImageSS3_New():
    return itkImageSS3.New()

class itkImageSS3(itkImageBase3):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageSS3___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageSS3_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageSS3_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageSS3_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageSS3_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageSS3_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageSS3_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageSS3_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageSS3_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageSS3_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageSS3_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageSS3_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageSS3
    cast = _swig_new_static_method(_itkImagePython.itkImageSS3_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageSS3

        Create a new object of the class itkImageSS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageSS3.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageSS3.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageSS3.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageSS3 in _itkImagePython:
_itkImagePython.itkImageSS3_swigregister(itkImageSS3)
itkImageSS3___New_orig__ = _itkImagePython.itkImageSS3___New_orig__
itkImageSS3_cast = _itkImagePython.itkImageSS3_cast


def itkImageSS4_New():
    return itkImageSS4.New()

class itkImageSS4(itkImageBase4):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageSS4___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageSS4_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageSS4_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageSS4_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageSS4_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageSS4_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageSS4_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageSS4_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageSS4_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageSS4_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageSS4_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageSS4_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageSS4
    cast = _swig_new_static_method(_itkImagePython.itkImageSS4_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageSS4

        Create a new object of the class itkImageSS4 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageSS4.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageSS4.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageSS4.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageSS4 in _itkImagePython:
_itkImagePython.itkImageSS4_swigregister(itkImageSS4)
itkImageSS4___New_orig__ = _itkImagePython.itkImageSS4___New_orig__
itkImageSS4_cast = _itkImagePython.itkImageSS4_cast


def itkImageSSRTD22_New():
    return itkImageSSRTD22.New()

class itkImageSSRTD22(itkImageBase2):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageSSRTD22___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageSSRTD22_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageSSRTD22_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageSSRTD22_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageSSRTD22_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageSSRTD22_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageSSRTD22_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageSSRTD22_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageSSRTD22_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageSSRTD22_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageSSRTD22_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageSSRTD22_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageSSRTD22
    cast = _swig_new_static_method(_itkImagePython.itkImageSSRTD22_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageSSRTD22

        Create a new object of the class itkImageSSRTD22 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageSSRTD22.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageSSRTD22.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageSSRTD22.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageSSRTD22 in _itkImagePython:
_itkImagePython.itkImageSSRTD22_swigregister(itkImageSSRTD22)
itkImageSSRTD22___New_orig__ = _itkImagePython.itkImageSSRTD22___New_orig__
itkImageSSRTD22_cast = _itkImagePython.itkImageSSRTD22_cast


def itkImageSSRTD33_New():
    return itkImageSSRTD33.New()

class itkImageSSRTD33(itkImageBase3):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageSSRTD33___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageSSRTD33_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageSSRTD33_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageSSRTD33_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageSSRTD33_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageSSRTD33_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageSSRTD33_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageSSRTD33_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageSSRTD33_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageSSRTD33_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageSSRTD33_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageSSRTD33_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageSSRTD33
    cast = _swig_new_static_method(_itkImagePython.itkImageSSRTD33_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageSSRTD33

        Create a new object of the class itkImageSSRTD33 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageSSRTD33.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageSSRTD33.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageSSRTD33.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageSSRTD33 in _itkImagePython:
_itkImagePython.itkImageSSRTD33_swigregister(itkImageSSRTD33)
itkImageSSRTD33___New_orig__ = _itkImagePython.itkImageSSRTD33___New_orig__
itkImageSSRTD33_cast = _itkImagePython.itkImageSSRTD33_cast


def itkImageSSRTD44_New():
    return itkImageSSRTD44.New()

class itkImageSSRTD44(itkImageBase4):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageSSRTD44___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageSSRTD44_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageSSRTD44_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageSSRTD44_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageSSRTD44_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageSSRTD44_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageSSRTD44_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageSSRTD44_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageSSRTD44_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageSSRTD44_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageSSRTD44_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageSSRTD44_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageSSRTD44
    cast = _swig_new_static_method(_itkImagePython.itkImageSSRTD44_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageSSRTD44

        Create a new object of the class itkImageSSRTD44 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageSSRTD44.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageSSRTD44.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageSSRTD44.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageSSRTD44 in _itkImagePython:
_itkImagePython.itkImageSSRTD44_swigregister(itkImageSSRTD44)
itkImageSSRTD44___New_orig__ = _itkImagePython.itkImageSSRTD44___New_orig__
itkImageSSRTD44_cast = _itkImagePython.itkImageSSRTD44_cast


def itkImageUC2_New():
    return itkImageUC2.New()

class itkImageUC2(itkImageBase2):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageUC2___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageUC2_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageUC2_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageUC2_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageUC2_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageUC2_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageUC2_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageUC2_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageUC2_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageUC2_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageUC2_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageUC2_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageUC2
    cast = _swig_new_static_method(_itkImagePython.itkImageUC2_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageUC2

        Create a new object of the class itkImageUC2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageUC2.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageUC2.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageUC2.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageUC2 in _itkImagePython:
_itkImagePython.itkImageUC2_swigregister(itkImageUC2)
itkImageUC2___New_orig__ = _itkImagePython.itkImageUC2___New_orig__
itkImageUC2_cast = _itkImagePython.itkImageUC2_cast


def itkImageUC3_New():
    return itkImageUC3.New()

class itkImageUC3(itkImageBase3):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageUC3___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageUC3_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageUC3_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageUC3_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageUC3_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageUC3_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageUC3_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageUC3_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageUC3_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageUC3_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageUC3_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageUC3_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageUC3
    cast = _swig_new_static_method(_itkImagePython.itkImageUC3_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageUC3

        Create a new object of the class itkImageUC3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageUC3.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageUC3.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageUC3.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageUC3 in _itkImagePython:
_itkImagePython.itkImageUC3_swigregister(itkImageUC3)
itkImageUC3___New_orig__ = _itkImagePython.itkImageUC3___New_orig__
itkImageUC3_cast = _itkImagePython.itkImageUC3_cast


def itkImageUC4_New():
    return itkImageUC4.New()

class itkImageUC4(itkImageBase4):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageUC4___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageUC4_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageUC4_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageUC4_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageUC4_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageUC4_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageUC4_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageUC4_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageUC4_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageUC4_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageUC4_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageUC4_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageUC4
    cast = _swig_new_static_method(_itkImagePython.itkImageUC4_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageUC4

        Create a new object of the class itkImageUC4 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageUC4.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageUC4.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageUC4.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageUC4 in _itkImagePython:
_itkImagePython.itkImageUC4_swigregister(itkImageUC4)
itkImageUC4___New_orig__ = _itkImagePython.itkImageUC4___New_orig__
itkImageUC4_cast = _itkImagePython.itkImageUC4_cast


def itkImageUI2_New():
    return itkImageUI2.New()

class itkImageUI2(itkImageBase2):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageUI2___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageUI2_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageUI2_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageUI2_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageUI2_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageUI2_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageUI2_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageUI2_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageUI2_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageUI2_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageUI2_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageUI2_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageUI2
    cast = _swig_new_static_method(_itkImagePython.itkImageUI2_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageUI2

        Create a new object of the class itkImageUI2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageUI2.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageUI2.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageUI2.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageUI2 in _itkImagePython:
_itkImagePython.itkImageUI2_swigregister(itkImageUI2)
itkImageUI2___New_orig__ = _itkImagePython.itkImageUI2___New_orig__
itkImageUI2_cast = _itkImagePython.itkImageUI2_cast


def itkImageUI3_New():
    return itkImageUI3.New()

class itkImageUI3(itkImageBase3):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageUI3___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageUI3_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageUI3_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageUI3_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageUI3_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageUI3_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageUI3_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageUI3_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageUI3_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageUI3_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageUI3_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageUI3_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageUI3
    cast = _swig_new_static_method(_itkImagePython.itkImageUI3_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageUI3

        Create a new object of the class itkImageUI3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageUI3.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageUI3.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageUI3.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageUI3 in _itkImagePython:
_itkImagePython.itkImageUI3_swigregister(itkImageUI3)
itkImageUI3___New_orig__ = _itkImagePython.itkImageUI3___New_orig__
itkImageUI3_cast = _itkImagePython.itkImageUI3_cast


def itkImageUI4_New():
    return itkImageUI4.New()

class itkImageUI4(itkImageBase4):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageUI4___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageUI4_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageUI4_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageUI4_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageUI4_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageUI4_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageUI4_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageUI4_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageUI4_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageUI4_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageUI4_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageUI4_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageUI4
    cast = _swig_new_static_method(_itkImagePython.itkImageUI4_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageUI4

        Create a new object of the class itkImageUI4 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageUI4.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageUI4.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageUI4.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageUI4 in _itkImagePython:
_itkImagePython.itkImageUI4_swigregister(itkImageUI4)
itkImageUI4___New_orig__ = _itkImagePython.itkImageUI4___New_orig__
itkImageUI4_cast = _itkImagePython.itkImageUI4_cast


def itkImageUL2_New():
    return itkImageUL2.New()

class itkImageUL2(itkImageBase2):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageUL2___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageUL2_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageUL2_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageUL2_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageUL2_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageUL2_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageUL2_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageUL2_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageUL2_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageUL2_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageUL2_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageUL2_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageUL2
    cast = _swig_new_static_method(_itkImagePython.itkImageUL2_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageUL2

        Create a new object of the class itkImageUL2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageUL2.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageUL2.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageUL2.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageUL2 in _itkImagePython:
_itkImagePython.itkImageUL2_swigregister(itkImageUL2)
itkImageUL2___New_orig__ = _itkImagePython.itkImageUL2___New_orig__
itkImageUL2_cast = _itkImagePython.itkImageUL2_cast


def itkImageUL3_New():
    return itkImageUL3.New()

class itkImageUL3(itkImageBase3):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageUL3___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageUL3_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageUL3_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageUL3_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageUL3_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageUL3_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageUL3_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageUL3_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageUL3_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageUL3_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageUL3_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageUL3_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageUL3
    cast = _swig_new_static_method(_itkImagePython.itkImageUL3_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageUL3

        Create a new object of the class itkImageUL3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageUL3.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageUL3.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageUL3.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageUL3 in _itkImagePython:
_itkImagePython.itkImageUL3_swigregister(itkImageUL3)
itkImageUL3___New_orig__ = _itkImagePython.itkImageUL3___New_orig__
itkImageUL3_cast = _itkImagePython.itkImageUL3_cast


def itkImageUL4_New():
    return itkImageUL4.New()

class itkImageUL4(itkImageBase4):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageUL4___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageUL4_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageUL4_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageUL4_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageUL4_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageUL4_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageUL4_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageUL4_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageUL4_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageUL4_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageUL4_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageUL4_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageUL4
    cast = _swig_new_static_method(_itkImagePython.itkImageUL4_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageUL4

        Create a new object of the class itkImageUL4 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageUL4.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageUL4.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageUL4.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageUL4 in _itkImagePython:
_itkImagePython.itkImageUL4_swigregister(itkImageUL4)
itkImageUL4___New_orig__ = _itkImagePython.itkImageUL4___New_orig__
itkImageUL4_cast = _itkImagePython.itkImageUL4_cast


def itkImageULL2_New():
    return itkImageULL2.New()

class itkImageULL2(itkImageBase2):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageULL2___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageULL2_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageULL2_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageULL2_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageULL2_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageULL2_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageULL2_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageULL2_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageULL2_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageULL2_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageULL2_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageULL2_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageULL2
    cast = _swig_new_static_method(_itkImagePython.itkImageULL2_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageULL2

        Create a new object of the class itkImageULL2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageULL2.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageULL2.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageULL2.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageULL2 in _itkImagePython:
_itkImagePython.itkImageULL2_swigregister(itkImageULL2)
itkImageULL2___New_orig__ = _itkImagePython.itkImageULL2___New_orig__
itkImageULL2_cast = _itkImagePython.itkImageULL2_cast


def itkImageULL3_New():
    return itkImageULL3.New()

class itkImageULL3(itkImageBase3):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageULL3___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageULL3_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageULL3_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageULL3_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageULL3_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageULL3_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageULL3_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageULL3_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageULL3_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageULL3_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageULL3_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageULL3_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageULL3
    cast = _swig_new_static_method(_itkImagePython.itkImageULL3_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageULL3

        Create a new object of the class itkImageULL3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageULL3.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageULL3.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageULL3.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageULL3 in _itkImagePython:
_itkImagePython.itkImageULL3_swigregister(itkImageULL3)
itkImageULL3___New_orig__ = _itkImagePython.itkImageULL3___New_orig__
itkImageULL3_cast = _itkImagePython.itkImageULL3_cast


def itkImageULL4_New():
    return itkImageULL4.New()

class itkImageULL4(itkImageBase4):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageULL4___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageULL4_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageULL4_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageULL4_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageULL4_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageULL4_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageULL4_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageULL4_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageULL4_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageULL4_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageULL4_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageULL4_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageULL4
    cast = _swig_new_static_method(_itkImagePython.itkImageULL4_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageULL4

        Create a new object of the class itkImageULL4 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageULL4.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageULL4.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageULL4.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageULL4 in _itkImagePython:
_itkImagePython.itkImageULL4_swigregister(itkImageULL4)
itkImageULL4___New_orig__ = _itkImagePython.itkImageULL4___New_orig__
itkImageULL4_cast = _itkImagePython.itkImageULL4_cast


def itkImageUS2_New():
    return itkImageUS2.New()

class itkImageUS2(itkImageBase2):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageUS2___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageUS2_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageUS2_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageUS2_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageUS2_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageUS2_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageUS2_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageUS2_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageUS2_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageUS2_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageUS2_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageUS2_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageUS2
    cast = _swig_new_static_method(_itkImagePython.itkImageUS2_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageUS2

        Create a new object of the class itkImageUS2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageUS2.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageUS2.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageUS2.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageUS2 in _itkImagePython:
_itkImagePython.itkImageUS2_swigregister(itkImageUS2)
itkImageUS2___New_orig__ = _itkImagePython.itkImageUS2___New_orig__
itkImageUS2_cast = _itkImagePython.itkImageUS2_cast


def itkImageUS3_New():
    return itkImageUS3.New()

class itkImageUS3(itkImageBase3):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageUS3___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageUS3_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageUS3_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageUS3_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageUS3_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageUS3_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageUS3_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageUS3_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageUS3_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageUS3_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageUS3_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageUS3_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageUS3
    cast = _swig_new_static_method(_itkImagePython.itkImageUS3_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageUS3

        Create a new object of the class itkImageUS3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageUS3.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageUS3.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageUS3.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageUS3 in _itkImagePython:
_itkImagePython.itkImageUS3_swigregister(itkImageUS3)
itkImageUS3___New_orig__ = _itkImagePython.itkImageUS3___New_orig__
itkImageUS3_cast = _itkImagePython.itkImageUS3_cast


def itkImageUS4_New():
    return itkImageUS4.New()

class itkImageUS4(itkImageBase4):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageUS4___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageUS4_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageUS4_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageUS4_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageUS4_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageUS4_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageUS4_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageUS4_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageUS4_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageUS4_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageUS4_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageUS4_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageUS4
    cast = _swig_new_static_method(_itkImagePython.itkImageUS4_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageUS4

        Create a new object of the class itkImageUS4 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageUS4.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageUS4.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageUS4.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageUS4 in _itkImagePython:
_itkImagePython.itkImageUS4_swigregister(itkImageUS4)
itkImageUS4___New_orig__ = _itkImagePython.itkImageUS4___New_orig__
itkImageUS4_cast = _itkImagePython.itkImageUS4_cast


def itkImageVD22_New():
    return itkImageVD22.New()

class itkImageVD22(itkImageBase2):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageVD22___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageVD22_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageVD22_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageVD22_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageVD22_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageVD22_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageVD22_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageVD22_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageVD22_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageVD22_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageVD22_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageVD22_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageVD22
    cast = _swig_new_static_method(_itkImagePython.itkImageVD22_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageVD22

        Create a new object of the class itkImageVD22 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageVD22.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageVD22.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageVD22.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageVD22 in _itkImagePython:
_itkImagePython.itkImageVD22_swigregister(itkImageVD22)
itkImageVD22___New_orig__ = _itkImagePython.itkImageVD22___New_orig__
itkImageVD22_cast = _itkImagePython.itkImageVD22_cast


def itkImageVD23_New():
    return itkImageVD23.New()

class itkImageVD23(itkImageBase3):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageVD23___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageVD23_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageVD23_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageVD23_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageVD23_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageVD23_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageVD23_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageVD23_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageVD23_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageVD23_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageVD23_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageVD23_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageVD23
    cast = _swig_new_static_method(_itkImagePython.itkImageVD23_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageVD23

        Create a new object of the class itkImageVD23 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageVD23.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageVD23.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageVD23.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageVD23 in _itkImagePython:
_itkImagePython.itkImageVD23_swigregister(itkImageVD23)
itkImageVD23___New_orig__ = _itkImagePython.itkImageVD23___New_orig__
itkImageVD23_cast = _itkImagePython.itkImageVD23_cast


def itkImageVD24_New():
    return itkImageVD24.New()

class itkImageVD24(itkImageBase4):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageVD24___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageVD24_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageVD24_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageVD24_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageVD24_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageVD24_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageVD24_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageVD24_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageVD24_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageVD24_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageVD24_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageVD24_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageVD24
    cast = _swig_new_static_method(_itkImagePython.itkImageVD24_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageVD24

        Create a new object of the class itkImageVD24 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageVD24.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageVD24.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageVD24.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageVD24 in _itkImagePython:
_itkImagePython.itkImageVD24_swigregister(itkImageVD24)
itkImageVD24___New_orig__ = _itkImagePython.itkImageVD24___New_orig__
itkImageVD24_cast = _itkImagePython.itkImageVD24_cast


def itkImageVD25_New():
    return itkImageVD25.New()

class itkImageVD25(itkImageBase5):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageVD25___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageVD25_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageVD25_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageVD25_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageVD25_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageVD25_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageVD25_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageVD25_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageVD25_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageVD25_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageVD25_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageVD25_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageVD25
    cast = _swig_new_static_method(_itkImagePython.itkImageVD25_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageVD25

        Create a new object of the class itkImageVD25 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageVD25.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageVD25.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageVD25.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageVD25 in _itkImagePython:
_itkImagePython.itkImageVD25_swigregister(itkImageVD25)
itkImageVD25___New_orig__ = _itkImagePython.itkImageVD25___New_orig__
itkImageVD25_cast = _itkImagePython.itkImageVD25_cast


def itkImageVD32_New():
    return itkImageVD32.New()

class itkImageVD32(itkImageBase2):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageVD32___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageVD32_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageVD32_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageVD32_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageVD32_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageVD32_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageVD32_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageVD32_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageVD32_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageVD32_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageVD32_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageVD32_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageVD32
    cast = _swig_new_static_method(_itkImagePython.itkImageVD32_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageVD32

        Create a new object of the class itkImageVD32 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageVD32.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageVD32.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageVD32.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageVD32 in _itkImagePython:
_itkImagePython.itkImageVD32_swigregister(itkImageVD32)
itkImageVD32___New_orig__ = _itkImagePython.itkImageVD32___New_orig__
itkImageVD32_cast = _itkImagePython.itkImageVD32_cast


def itkImageVD33_New():
    return itkImageVD33.New()

class itkImageVD33(itkImageBase3):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageVD33___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageVD33_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageVD33_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageVD33_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageVD33_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageVD33_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageVD33_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageVD33_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageVD33_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageVD33_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageVD33_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageVD33_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageVD33
    cast = _swig_new_static_method(_itkImagePython.itkImageVD33_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageVD33

        Create a new object of the class itkImageVD33 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageVD33.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageVD33.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageVD33.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageVD33 in _itkImagePython:
_itkImagePython.itkImageVD33_swigregister(itkImageVD33)
itkImageVD33___New_orig__ = _itkImagePython.itkImageVD33___New_orig__
itkImageVD33_cast = _itkImagePython.itkImageVD33_cast


def itkImageVD34_New():
    return itkImageVD34.New()

class itkImageVD34(itkImageBase4):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageVD34___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageVD34_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageVD34_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageVD34_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageVD34_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageVD34_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageVD34_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageVD34_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageVD34_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageVD34_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageVD34_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageVD34_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageVD34
    cast = _swig_new_static_method(_itkImagePython.itkImageVD34_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageVD34

        Create a new object of the class itkImageVD34 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageVD34.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageVD34.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageVD34.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageVD34 in _itkImagePython:
_itkImagePython.itkImageVD34_swigregister(itkImageVD34)
itkImageVD34___New_orig__ = _itkImagePython.itkImageVD34___New_orig__
itkImageVD34_cast = _itkImagePython.itkImageVD34_cast


def itkImageVD35_New():
    return itkImageVD35.New()

class itkImageVD35(itkImageBase5):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageVD35___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageVD35_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageVD35_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageVD35_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageVD35_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageVD35_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageVD35_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageVD35_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageVD35_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageVD35_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageVD35_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageVD35_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageVD35
    cast = _swig_new_static_method(_itkImagePython.itkImageVD35_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageVD35

        Create a new object of the class itkImageVD35 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageVD35.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageVD35.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageVD35.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageVD35 in _itkImagePython:
_itkImagePython.itkImageVD35_swigregister(itkImageVD35)
itkImageVD35___New_orig__ = _itkImagePython.itkImageVD35___New_orig__
itkImageVD35_cast = _itkImagePython.itkImageVD35_cast


def itkImageVD42_New():
    return itkImageVD42.New()

class itkImageVD42(itkImageBase2):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageVD42___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageVD42_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageVD42_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageVD42_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageVD42_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageVD42_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageVD42_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageVD42_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageVD42_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageVD42_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageVD42_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageVD42_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageVD42
    cast = _swig_new_static_method(_itkImagePython.itkImageVD42_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageVD42

        Create a new object of the class itkImageVD42 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageVD42.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageVD42.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageVD42.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageVD42 in _itkImagePython:
_itkImagePython.itkImageVD42_swigregister(itkImageVD42)
itkImageVD42___New_orig__ = _itkImagePython.itkImageVD42___New_orig__
itkImageVD42_cast = _itkImagePython.itkImageVD42_cast


def itkImageVD43_New():
    return itkImageVD43.New()

class itkImageVD43(itkImageBase3):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageVD43___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageVD43_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageVD43_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageVD43_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageVD43_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageVD43_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageVD43_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageVD43_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageVD43_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageVD43_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageVD43_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageVD43_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageVD43
    cast = _swig_new_static_method(_itkImagePython.itkImageVD43_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageVD43

        Create a new object of the class itkImageVD43 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageVD43.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageVD43.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageVD43.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageVD43 in _itkImagePython:
_itkImagePython.itkImageVD43_swigregister(itkImageVD43)
itkImageVD43___New_orig__ = _itkImagePython.itkImageVD43___New_orig__
itkImageVD43_cast = _itkImagePython.itkImageVD43_cast


def itkImageVD44_New():
    return itkImageVD44.New()

class itkImageVD44(itkImageBase4):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageVD44___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageVD44_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageVD44_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageVD44_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageVD44_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageVD44_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageVD44_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageVD44_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageVD44_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageVD44_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageVD44_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageVD44_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageVD44
    cast = _swig_new_static_method(_itkImagePython.itkImageVD44_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageVD44

        Create a new object of the class itkImageVD44 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageVD44.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageVD44.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageVD44.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageVD44 in _itkImagePython:
_itkImagePython.itkImageVD44_swigregister(itkImageVD44)
itkImageVD44___New_orig__ = _itkImagePython.itkImageVD44___New_orig__
itkImageVD44_cast = _itkImagePython.itkImageVD44_cast


def itkImageVD45_New():
    return itkImageVD45.New()

class itkImageVD45(itkImageBase5):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageVD45___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageVD45_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageVD45_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageVD45_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageVD45_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageVD45_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageVD45_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageVD45_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageVD45_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageVD45_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageVD45_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageVD45_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageVD45
    cast = _swig_new_static_method(_itkImagePython.itkImageVD45_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageVD45

        Create a new object of the class itkImageVD45 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageVD45.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageVD45.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageVD45.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageVD45 in _itkImagePython:
_itkImagePython.itkImageVD45_swigregister(itkImageVD45)
itkImageVD45___New_orig__ = _itkImagePython.itkImageVD45___New_orig__
itkImageVD45_cast = _itkImagePython.itkImageVD45_cast


def itkImageVF12_New():
    return itkImageVF12.New()

class itkImageVF12(itkImageBase2):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageVF12___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageVF12_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageVF12_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageVF12_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageVF12_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageVF12_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageVF12_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageVF12_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageVF12_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageVF12_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageVF12_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageVF12_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageVF12
    cast = _swig_new_static_method(_itkImagePython.itkImageVF12_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageVF12

        Create a new object of the class itkImageVF12 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageVF12.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageVF12.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageVF12.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageVF12 in _itkImagePython:
_itkImagePython.itkImageVF12_swigregister(itkImageVF12)
itkImageVF12___New_orig__ = _itkImagePython.itkImageVF12___New_orig__
itkImageVF12_cast = _itkImagePython.itkImageVF12_cast


def itkImageVF13_New():
    return itkImageVF13.New()

class itkImageVF13(itkImageBase3):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageVF13___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageVF13_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageVF13_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageVF13_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageVF13_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageVF13_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageVF13_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageVF13_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageVF13_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageVF13_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageVF13_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageVF13_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageVF13
    cast = _swig_new_static_method(_itkImagePython.itkImageVF13_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageVF13

        Create a new object of the class itkImageVF13 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageVF13.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageVF13.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageVF13.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageVF13 in _itkImagePython:
_itkImagePython.itkImageVF13_swigregister(itkImageVF13)
itkImageVF13___New_orig__ = _itkImagePython.itkImageVF13___New_orig__
itkImageVF13_cast = _itkImagePython.itkImageVF13_cast


def itkImageVF14_New():
    return itkImageVF14.New()

class itkImageVF14(itkImageBase4):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageVF14___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageVF14_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageVF14_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageVF14_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageVF14_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageVF14_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageVF14_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageVF14_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageVF14_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageVF14_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageVF14_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageVF14_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageVF14
    cast = _swig_new_static_method(_itkImagePython.itkImageVF14_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageVF14

        Create a new object of the class itkImageVF14 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageVF14.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageVF14.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageVF14.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageVF14 in _itkImagePython:
_itkImagePython.itkImageVF14_swigregister(itkImageVF14)
itkImageVF14___New_orig__ = _itkImagePython.itkImageVF14___New_orig__
itkImageVF14_cast = _itkImagePython.itkImageVF14_cast


def itkImageVF22_New():
    return itkImageVF22.New()

class itkImageVF22(itkImageBase2):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageVF22___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageVF22_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageVF22_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageVF22_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageVF22_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageVF22_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageVF22_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageVF22_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageVF22_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageVF22_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageVF22_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageVF22_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageVF22
    cast = _swig_new_static_method(_itkImagePython.itkImageVF22_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageVF22

        Create a new object of the class itkImageVF22 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageVF22.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageVF22.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageVF22.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageVF22 in _itkImagePython:
_itkImagePython.itkImageVF22_swigregister(itkImageVF22)
itkImageVF22___New_orig__ = _itkImagePython.itkImageVF22___New_orig__
itkImageVF22_cast = _itkImagePython.itkImageVF22_cast


def itkImageVF23_New():
    return itkImageVF23.New()

class itkImageVF23(itkImageBase3):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageVF23___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageVF23_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageVF23_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageVF23_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageVF23_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageVF23_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageVF23_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageVF23_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageVF23_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageVF23_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageVF23_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageVF23_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageVF23
    cast = _swig_new_static_method(_itkImagePython.itkImageVF23_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageVF23

        Create a new object of the class itkImageVF23 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageVF23.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageVF23.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageVF23.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageVF23 in _itkImagePython:
_itkImagePython.itkImageVF23_swigregister(itkImageVF23)
itkImageVF23___New_orig__ = _itkImagePython.itkImageVF23___New_orig__
itkImageVF23_cast = _itkImagePython.itkImageVF23_cast


def itkImageVF24_New():
    return itkImageVF24.New()

class itkImageVF24(itkImageBase4):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageVF24___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageVF24_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageVF24_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageVF24_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageVF24_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageVF24_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageVF24_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageVF24_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageVF24_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageVF24_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageVF24_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageVF24_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageVF24
    cast = _swig_new_static_method(_itkImagePython.itkImageVF24_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageVF24

        Create a new object of the class itkImageVF24 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageVF24.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageVF24.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageVF24.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageVF24 in _itkImagePython:
_itkImagePython.itkImageVF24_swigregister(itkImageVF24)
itkImageVF24___New_orig__ = _itkImagePython.itkImageVF24___New_orig__
itkImageVF24_cast = _itkImagePython.itkImageVF24_cast


def itkImageVF32_New():
    return itkImageVF32.New()

class itkImageVF32(itkImageBase2):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageVF32___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageVF32_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageVF32_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageVF32_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageVF32_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageVF32_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageVF32_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageVF32_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageVF32_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageVF32_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageVF32_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageVF32_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageVF32
    cast = _swig_new_static_method(_itkImagePython.itkImageVF32_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageVF32

        Create a new object of the class itkImageVF32 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageVF32.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageVF32.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageVF32.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageVF32 in _itkImagePython:
_itkImagePython.itkImageVF32_swigregister(itkImageVF32)
itkImageVF32___New_orig__ = _itkImagePython.itkImageVF32___New_orig__
itkImageVF32_cast = _itkImagePython.itkImageVF32_cast


def itkImageVF33_New():
    return itkImageVF33.New()

class itkImageVF33(itkImageBase3):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageVF33___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageVF33_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageVF33_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageVF33_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageVF33_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageVF33_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageVF33_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageVF33_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageVF33_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageVF33_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageVF33_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageVF33_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageVF33
    cast = _swig_new_static_method(_itkImagePython.itkImageVF33_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageVF33

        Create a new object of the class itkImageVF33 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageVF33.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageVF33.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageVF33.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageVF33 in _itkImagePython:
_itkImagePython.itkImageVF33_swigregister(itkImageVF33)
itkImageVF33___New_orig__ = _itkImagePython.itkImageVF33___New_orig__
itkImageVF33_cast = _itkImagePython.itkImageVF33_cast


def itkImageVF34_New():
    return itkImageVF34.New()

class itkImageVF34(itkImageBase4):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageVF34___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageVF34_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageVF34_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageVF34_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageVF34_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageVF34_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageVF34_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageVF34_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageVF34_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageVF34_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageVF34_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageVF34_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageVF34
    cast = _swig_new_static_method(_itkImagePython.itkImageVF34_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageVF34

        Create a new object of the class itkImageVF34 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageVF34.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageVF34.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageVF34.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageVF34 in _itkImagePython:
_itkImagePython.itkImageVF34_swigregister(itkImageVF34)
itkImageVF34___New_orig__ = _itkImagePython.itkImageVF34___New_orig__
itkImageVF34_cast = _itkImagePython.itkImageVF34_cast


def itkImageVF42_New():
    return itkImageVF42.New()

class itkImageVF42(itkImageBase2):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageVF42___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageVF42_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageVF42_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageVF42_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageVF42_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageVF42_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageVF42_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageVF42_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageVF42_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageVF42_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageVF42_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageVF42_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageVF42
    cast = _swig_new_static_method(_itkImagePython.itkImageVF42_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageVF42

        Create a new object of the class itkImageVF42 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageVF42.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageVF42.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageVF42.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageVF42 in _itkImagePython:
_itkImagePython.itkImageVF42_swigregister(itkImageVF42)
itkImageVF42___New_orig__ = _itkImagePython.itkImageVF42___New_orig__
itkImageVF42_cast = _itkImagePython.itkImageVF42_cast


def itkImageVF43_New():
    return itkImageVF43.New()

class itkImageVF43(itkImageBase3):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageVF43___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageVF43_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageVF43_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageVF43_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageVF43_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageVF43_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageVF43_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageVF43_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageVF43_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageVF43_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageVF43_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageVF43_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageVF43
    cast = _swig_new_static_method(_itkImagePython.itkImageVF43_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageVF43

        Create a new object of the class itkImageVF43 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageVF43.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageVF43.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageVF43.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageVF43 in _itkImagePython:
_itkImagePython.itkImageVF43_swigregister(itkImageVF43)
itkImageVF43___New_orig__ = _itkImagePython.itkImageVF43___New_orig__
itkImageVF43_cast = _itkImagePython.itkImageVF43_cast


def itkImageVF44_New():
    return itkImageVF44.New()

class itkImageVF44(itkImageBase4):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageVF44___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageVF44_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageVF44_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageVF44_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageVF44_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageVF44_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageVF44_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageVF44_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageVF44_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageVF44_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageVF44_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageVF44_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageVF44
    cast = _swig_new_static_method(_itkImagePython.itkImageVF44_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageVF44

        Create a new object of the class itkImageVF44 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageVF44.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageVF44.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageVF44.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageVF44 in _itkImagePython:
_itkImagePython.itkImageVF44_swigregister(itkImageVF44)
itkImageVF44___New_orig__ = _itkImagePython.itkImageVF44___New_orig__
itkImageVF44_cast = _itkImagePython.itkImageVF44_cast


def itkImageB2_New():
    return itkImageB2.New()

class itkImageB2(itkImageBase2):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageB2___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageB2_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageB2_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageB2_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageB2_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageB2_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageB2_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageB2_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageB2_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageB2_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageB2_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageB2_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageB2
    cast = _swig_new_static_method(_itkImagePython.itkImageB2_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageB2

        Create a new object of the class itkImageB2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageB2.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageB2.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageB2.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageB2 in _itkImagePython:
_itkImagePython.itkImageB2_swigregister(itkImageB2)
itkImageB2___New_orig__ = _itkImagePython.itkImageB2___New_orig__
itkImageB2_cast = _itkImagePython.itkImageB2_cast


def itkImageB3_New():
    return itkImageB3.New()

class itkImageB3(itkImageBase3):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageB3___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageB3_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageB3_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageB3_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageB3_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageB3_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageB3_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageB3_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageB3_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageB3_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageB3_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageB3_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageB3
    cast = _swig_new_static_method(_itkImagePython.itkImageB3_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageB3

        Create a new object of the class itkImageB3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageB3.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageB3.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageB3.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageB3 in _itkImagePython:
_itkImagePython.itkImageB3_swigregister(itkImageB3)
itkImageB3___New_orig__ = _itkImagePython.itkImageB3___New_orig__
itkImageB3_cast = _itkImagePython.itkImageB3_cast


def itkImageB4_New():
    return itkImageB4.New()

class itkImageB4(itkImageBase4):
    r"""


    Templated n-dimensional image class.

    Images are templated over a pixel type (modeling the dependent
    variables), and a dimension (number of independent variables). The
    container for the pixel data is the ImportImageContainer.

    Within the pixel container, images are modelled as arrays, defined by
    a start index and a size.

    The superclass of Image, ImageBase, defines the geometry of the image
    in terms of where the image sits in physical space, how the image is
    oriented in physical space, the size of a pixel, and the extent of the
    image itself. ImageBase provides the methods to convert between the
    index and physical space coordinate frames.

    Pixels can be accessed directly using the SetPixel() and GetPixel()
    methods or can be accessed via iterators that define the region of the
    image they traverse.

    The pixel type may be one of the native types; a Insight-defined class
    type such as Vector; or a user-defined type. Note that depending on
    the type of pixel that you use, the process objects (i.e., those
    filters processing data objects) may not operate on the image and/or
    pixel type. This becomes apparent at compile-time because operator
    overloading (for the pixel type) is not supported.

    The data in an image is arranged in a 1D array as
    [][][][slice][row][col] with the column index varying most rapidly.
    The Index type reverses the order so that with Index[0] = col,
    Index[1] = row, Index[2] = slice, ...

    See:   ImageBase

    See:  ImageContainerInterface 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkImagePython.itkImageB4___New_orig__)
    Clone = _swig_new_instance_method(_itkImagePython.itkImageB4_Clone)
    Allocate = _swig_new_instance_method(_itkImagePython.itkImageB4_Allocate)
    FillBuffer = _swig_new_instance_method(_itkImagePython.itkImageB4_FillBuffer)
    SetPixel = _swig_new_instance_method(_itkImagePython.itkImageB4_SetPixel)
    GetPixel = _swig_new_instance_method(_itkImagePython.itkImageB4_GetPixel)
    GetBufferPointer = _swig_new_instance_method(_itkImagePython.itkImageB4_GetBufferPointer)
    GetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageB4_GetPixelContainer)
    SetPixelContainer = _swig_new_instance_method(_itkImagePython.itkImageB4_SetPixelContainer)
    Graft = _swig_new_instance_method(_itkImagePython.itkImageB4_Graft)
    GetPixelAccessor = _swig_new_instance_method(_itkImagePython.itkImageB4_GetPixelAccessor)
    GetNeighborhoodAccessor = _swig_new_instance_method(_itkImagePython.itkImageB4_GetNeighborhoodAccessor)
    __swig_destroy__ = _itkImagePython.delete_itkImageB4
    cast = _swig_new_static_method(_itkImagePython.itkImageB4_cast)

    def __array__(self, dtype=None):
        import itk
        import numpy as np
        array = itk.array_from_image(self)
        return np.asarray(array, dtype=dtype)


    def New(*args, **kargs):
        """New() -> itkImageB4

        Create a new object of the class itkImageB4 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkImageB4.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkImageB4.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkImageB4.__New_orig__()
        from itk.support import template_class
        template_class.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkImageB4 in _itkImagePython:
_itkImagePython.itkImageB4_swigregister(itkImageB4)
itkImageB4___New_orig__ = _itkImagePython.itkImageB4___New_orig__
itkImageB4_cast = _itkImagePython.itkImageB4_cast



